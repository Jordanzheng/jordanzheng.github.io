[{"categories":["经验总结"],"content":"前言 最近抽空将前段时间负责重构服务迁移数据的项目总结一下。主要涉及mysql分表、数据迁移等方面。由于分库分表面对的场景很多，具体问题具体分析，还是要依据当时项目的实际情况，选择最合理的方案。 一、项目背景 近来接手负责一个项目，需要重构业务的实名认证系统。当前该实名认证系统随着业务的增长以及红包活动复用实名认证表，用户实名认证表的数据迅速增长。基于下面几点原因，不得不重构系统，数据分表，迁移数据。 1、由于历史原因，实名认证表是单表，数据量已经达到三千万左右。mysql单表数据量过千万上亿级别就会对服务造成很大的影响。 数据库备份，如果单表太大，备份时需要大量的磁盘IO和网络IO 后续很难对该表进行DDL修改 大表会经常访问与更新，就更有可能出现锁等待。将数据切分，用空间换时间，变相降低访问压力） 2、该表主键uid之前是32位，为后续可以扩展，升级为64位，同时新增更新时间字段。 3、当前该服务以及外部服务直接操作数据库表。耦合严重。 二、方案设计 ","date":"2019-09-14","objectID":"/mysql-sharding/:0:0","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"1、数据表怎么切分 数据切分通常分为两种方式：垂直切分和水平切分 1、垂直切分就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与\"微服务治理\"的做法相似，每个微服务使用单独的一个数据库。 2、水平切分就是将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小。 常见的分片规则： 1、按时间区间或者id区间来切分。例如：按日期将不同月甚至是日的数据分散到不同的库中；将userId为19999的记录分到第一个库，1000020000的分到第二个库，以此类推。某种意义上，某些系统中使用的\"冷热数据分离\"，将一些使用较少的历史数据迁移到其他库中，业务功能上只提供热点数据的查询，也是类似的实践。 优点： 单表大小可控 天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移 使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。 缺点： 热点数据成为性能瓶颈。连续分片可能存在数据热点，例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询 2、根据数值取模。一般采用hash取模mod的切分方式 优点： 数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈 缺点： 后期分片集群扩容时，需要迁移旧的数据（使用一致性hash[“算法”]能较好的避免这个问题） 容易面临跨分片查询的复杂问题。 因为实名认证表没有时间维度字段，主键uid同时也是用户唯一id，由账号系统生成。本次数据表切分最后采用按用户uid维度取模水平切分。考虑到后续业务的增长，按uid%100取模，切分成100张表，平均每张表的数量不到百万级别，可支持后续上亿的用户数据。 优点： 数据均匀分布在100张表中 每张表的数据量不会太大 缺点： 一次性增加100张表 没法反向关系查询，例如根据手机号查找对应的uid，这个通过在缓存中增加手机号—\u003euid反向关系解决 ","date":"2019-09-14","objectID":"/mysql-sharding/:1:0","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"2、数据怎么迁移 互联网很多“数据量较大，并发量较大，业务复杂度较高”的业务场景，例如在（1）底层表结构变更（2）分库个数变换（3）底层存储介质变换的众多需求下，需要进行数据迁移，如何“平滑迁移数据，迁移过程不停机，保证系统持续服务”。 常见的几种数据迁移方案： ","date":"2019-09-14","objectID":"/mysql-sharding/:2:0","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"1） 停机方案 优点：停机方案是相对直观和简单的，但对服务的可用性有影响，许多游戏公司的服务器升级，游戏分区与合区，可能会采用类似的方案 缺点：1、影响服务可用性；2、指定时间内升级 ；3、容错性低，一旦规定时间内升级失败，只能回滚。 ","date":"2019-09-14","objectID":"/mysql-sharding/:2:1","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"2) 平滑迁移–追日志法 步骤一：服务进行升级，记录“对旧库上的数据修改”的日志，该日志只需记录关键信息 步骤二：研发一个数据迁移工具，进行数据迁移 步骤三：研发一个读取日志并迁移数据的小工具，要把步骤二迁移数据过程中产生的差异数据追平 步骤四：在持续重放日志，追平数据的过程中，研发一个数据校验的小工具，将旧库和新库中的数据进行比对，直到数据完全一致。 数据一直是99.9%的一致，不能完全一致，也是正常的，可以做一个秒级的旧库readonly，等日志重放程序完全追上数据后，再进行切库切流量。 ","date":"2019-09-14","objectID":"/mysql-sharding/:2:2","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"3）平滑迁移–双写法 步骤一：服务进行升级，对“对旧库上的数据修改”（这里的修改，为数据的insert, delete, update），在新库上进行相同的修改操作 步骤二：研发一个数据迁移工具，进行数据迁移 步骤三：在数据迁移完成之后，需要使用数据校验的小工具，将旧库和新库中的数据进行比对，完全一致则符合预期，如果出现步骤二中的极限不一致情况，则以旧库中的数据为准。 步骤四：数据完全一致之后，将流量切到新库，完成平滑数据迁移。 （1）假设迁移过程中进行了一个双insert操作，旧库新库都插入了数据，数据一致性没有被破坏 （2）假设迁移过程中进行了一个双delete操作，这又分为两种情况： ​ （2.1）假设这delete的数据属于[min,now]范围，即已经完成迁移，则旧库新库都删除了数据，数据一致性没有被破坏。 ​ （2.2）假设这delete的数据属于[now,max]范围，即未完成迁移，则旧库中删除操作的affect rows为1，新库中删除操作的affect rows为0，但是数据迁移工具在后续数据迁移中，并不会将这条旧库中被删除的数据迁移到新库中，所以数据一致性仍没有被破坏 （3）假设迁移过程中进行了一个双update操作，可以认为update操作是一个delete加一个insert操作的复合操作，所以数据仍然是一致的 除非在一种非常非常非常极限的情况下： （1）date-migrate-tool刚好从旧库中将某一条数据X取出 （2）在X插入到新库中之前，旧库与新库中刚好对X进行了双delete操作 （3）date-migrate-tool再将X插入到新库中 这样，会出现新库比旧库多出一条数据X。 不管怎样，数据迁移完成之后，在数据迁移完成之后，需要使用数据校验的小工具，将旧库和新库中的数据进行比对，完全一致则符合预期，如果出现步骤二中的极限不一致情况，则以旧库中的数据为准。 此次重构项目中数据分两步迁移完成，数据从老表迁移到新表中。 在数据校验一致之前，所有的数据均以老表中的数据为准 。 因为认证信息表中无法以时间维度来迁移数据，只能通过主键uid导出老表中的数据，然后迁移到新表中。因为数据量接近3000万，所以采用mysql提供的LOAD DATA INFILE导入文件的形式导入数据，这样可大大缩短数据导入时间。LOAD DATA INFILE 语句以很高的速度从一个文本文件中读取行到一个表中。 1、迁移存量数据 为了保证不影响现网服务，读取老表的数据将从从库中读取。为了合理控制迁移数据的时长，并发的select老表的数据，在测试环境测试，迁移3000万的数据大概耗时1小时。 2、迁移增量数据 增量数据通过后面数据校验工具对比完成 ","date":"2019-09-14","objectID":"/mysql-sharding/:2:3","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"3、怎么保证数据一致性 以 数据双写服务上线的时间 为分割点，分割点之前数据的一致性由数据迁移脚本来保证；分割点以后的数据一致性由新老表双写来保证；当然这些数据的一致性都会有检验机制。 1、对于数据迁移脚本迁移的数据一致性校验：数据根据uid取模从老表中分别存到100个文本文件中，当数据导入到每张新表后，直接再拉取新表数据到文本中，然后分别校验100个新老文件的MD5值，若都相同，则存量数据一致性没问题。 2、对于数据库双写保证数据一致性校验：在老表执行成功后才会旁路发hippo（公司内部的消息队列组件）操作新表，hippo消息队列做消息的可靠性保证，新表操作如果失败通过monitor上报告警、error日志记录来保证一致性，如果没有告警和error日志，则可以认为双写数据的一致性。 3、数据校验工具校验一致性：当存量数据导入新库之后，这是就通过数据校验工具比对新老库数据的一致性。为了不影响现网服务，数据校验比对拉的是老表的从库。当所有数据多次都比对一致后，此时新老库的数据就完全一致。 ","date":"2019-09-14","objectID":"/mysql-sharding/:3:0","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"4、怎么保证不影响线上服务 为了不影响实名认证系统及周边业务方的线上服务，此次重构系统分三次迭代上线： ","date":"2019-09-14","objectID":"/mysql-sharding/:4:0","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"1）上线数据库新老表双写 迭代一主要保证新老表数据双写。实名认证老服务在原来写老表操作的地方，旁路一份数据到消息队列中，由新服务消费这个消息队列的消息写入到新表，同时也缓存一份数据到ckv（公司的缓存组件），并且存储由于分表导致无法反向查询手机号-\u003euid的反向关系。旁路消息，异步处理这样不影响到原来的业务流程。 ","date":"2019-09-14","objectID":"/mysql-sharding/:4:1","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"2）上线数据同步，保证数据库新老表数据一致 迭代二主要是上线数据同步服务，将老表的存量数据迁移到新表中，并且通过数据校验服务比对新老表数据的一致性。这个过程中，实名认证和业务方仍然使用老表。 ","date":"2019-09-14","objectID":"/mysql-sharding/:4:2","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"3）上线切换使用新表、ckv数据，提供新的接口， 迭代三上线切换使用新表，读接口使用ckv缓存数据，写接口先更新数据库再更新缓存，同时也会旁路消息更新老表，老表作为备份。迭代三过程中排查业务方的影响，将分表项目知会到业务方，业务方配合修改自己的逻辑。原有直接访问数据库表的调用一律切换成接口调用。严格控制上线步骤，不影响现网服务。 ","date":"2019-09-14","objectID":"/mysql-sharding/:4:3","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"5、为什么选择这个方案 方案初期也考虑了几种方案： 1、引入开源的数据库中间件如mycat、sharding-sphere等。但是引入第三方组件，增加系统复杂度，后续升级发布麻烦，mycat还需额外单独部署机器，增加运维成本。 2、停服迁移数据方案。该方案要停机，这样会影响到用户使用。 综上，最终选择不引入第三方组件，数据双写不停服的方案。 三、参考文章 1、100亿数据平滑数据迁移,不影响服务 2、数据库分库分表思路 3、记一次分库分表——改造策略总结 ","date":"2019-09-14","objectID":"/mysql-sharding/:5:0","tags":["数据库","mysql","分库分表"],"title":"mysql千万级数据分表迁移方案","uri":"/mysql-sharding/"},{"categories":["经验总结"],"content":"互联网业务快速发展，经常遇到业务在设计表时只是单表，后面随着业务快速发展，单表数据量达到千万级别，甚至上亿级别。此时mysql单表性能下降，解决办法之一是分表。 批量创建多张表结构一样的表，方法有很多，本文介绍两种，仅供参考： ","date":"2019-08-17","objectID":"/batch-create-table-mysql/:0:0","tags":["数据库","mysql"],"title":"mysql批量创建表","uri":"/batch-create-table-mysql/"},{"categories":["经验总结"],"content":"一、存储过程创建多张表 ","date":"2019-08-17","objectID":"/batch-create-table-mysql/:1:0","tags":["数据库","mysql"],"title":"mysql批量创建表","uri":"/batch-create-table-mysql/"},{"categories":["经验总结"],"content":"1、创建一百张表 createTable.sql #创建数据库要先指定字符集，否则使用数据库的默认字符集 CREATE DATABASE db_test DEFAULT CHARACTER SET UTF8; USE db_test; CALL create_table(); #-------------------以下是存储过程-------------- DELIMITER $$ CREATE PROCEDURE `db_test`.`create_table`() BEGIN DECLARE i INT; DECLARE table_name VARCHAR(30); DECLARE table_pre VARCHAR(30); DECLARE sql_text VARCHAR(3000); SET i=0; SET table_name=''; SET table_pre='test_table_'; SET sql_text=''; WHILE i\u003c100 DO SET table_name=CONCAT(table_pre,i); SET sql_text=CONCAT('CREATE TABLE ', table_name, ' ( `uid` BIGINT(11) unsigned NOT NULL COMMENT \\'统一ID\\', `name` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT \\'姓名\\', `idcard` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT \\'身份证\\', `idcard_url` varchar(256) COLLATE utf8_bin DEFAULT NULL COMMENT \\'身份证图片\\', `idcard_auth_status` int(4) unsigned DEFAULT 0 COMMENT \\'身份证认证状态\\', `idcard_auth_time` BIGINT(12) unsigned DEFAULT 0 COMMENT \\'身份证认证时间\\', `phone` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT \\'手机号码\\', `phone_auth_status` int(4) unsigned DEFAULT 0 COMMENT \\'手机认证状态\\', `phone_auth_time` BIGINT(12) unsigned DEFAULT 0 COMMENT \\'手机认证时间\\', `update_time` BIGINT(12) unsigned DEFAULT 0 COMMENT \\'更新时间\\', PRIMARY KEY (`uid`), KEY `index_name` (`phone`(11)), KEY `index_idcard` (`idcard`(18)), ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin CHECKSUM=1 DELAY_KEY_WRITE=1 ROW_FORMAT=DYNAMIC' ); SELECT sql_text; SET @sql_text=sql_text; PREPARE stmt FROM @sql_text; EXECUTE stmt; DEALLOCATE PREPARE stmt; SET i=i+1; END WHILE; END$$ DELIMITER ; ","date":"2019-08-17","objectID":"/batch-create-table-mysql/:1:1","tags":["数据库","mysql"],"title":"mysql批量创建表","uri":"/batch-create-table-mysql/"},{"categories":["经验总结"],"content":"2、执行存储过程，创建表 登上mysql，执行createTable.sql即可 ","date":"2019-08-17","objectID":"/batch-create-table-mysql/:1:2","tags":["数据库","mysql"],"title":"mysql批量创建表","uri":"/batch-create-table-mysql/"},{"categories":["经验总结"],"content":"二、利用sql语句创建多张表 #!/bin/sh # 数据表名定义 timestamp=`date -d \"3 month ago\" +%Y%m%d` tablename='t_table_test_20191108' sql=\"CREATE TABLE $tablename ( id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '唯一id', uid BIGINT(20) UNSIGNED NOT NULL DEFAULT '0' COMMENT 'uid', msg_id VARCHAR(64) NOT NULL DEFAULT '' COMMENT '消息id', msg_ts BIGINT(20) NOT NULL DEFAULT '0' COMMENT '发言时间戳', sender_uid BIGINT(20) UNSIGNED NOT NULL DEFAULT '0' COMMENT '发言者uid', sender_nic VARCHAR(64) NOT NULL DEFAULT '' COMMENT '发言者昵称', text VARCHAR(2048) NOT NULL DEFAULT '' COMMENT '发言内容', update_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (id), UNIQUE INDEX idx_msg_id (msg_id), INDEX idx_anchor_uid_msg_ts (anchor_uid, msg_ts) )COLLATE='utf8mb4_general_ci' ENGINE=InnoDB AUTO_INCREMENT=1000;\" mysql -h 10.23.22.22 -udb_test -pdb_test -P2223 -Ddb_test --default-character-set=utf8 -Ne \"$sql\" 如果字段名和mysql关键字重复，将字段名用****括起来，例如：index` #!/bin/sh # 数据表名定义 timestamp=`date -d \"3 month ago\" +%Y%m%d` tablename='t_table_test_20191108' sql=\"CREATE TABLE $tablename ( \\`id \\` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '唯一id', \\`uid \\` BIGINT(20) UNSIGNED NOT NULL DEFAULT '0' COMMENT 'uid', \\`msg_id\\` VARCHAR(64) NOT NULL DEFAULT '' COMMENT '消息id', \\`msg_ts\\` BIGINT(20) NOT NULL DEFAULT '0' COMMENT '发言时间戳', \\`sender_uid\\` BIGINT(20) UNSIGNED NOT NULL DEFAULT '0' COMMENT '发言者uid', \\`sender_nic\\` VARCHAR(64) NOT NULL DEFAULT '' COMMENT '发言者昵称', \\`text\\` VARCHAR(2048) NOT NULL DEFAULT '' COMMENT '发言内容', \\`update_time\\` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (\\`id\\`), UNIQUE INDEX idx_msg_id (\\`msg_id\\`), INDEX idx_anchor_uid_msg_ts (\\`anchor_uid\\`, \\`msg_ts\\`) )COLLATE='utf8mb4_general_ci' ENGINE=InnoDB AUTO_INCREMENT=1000;\" mysql -h 10.23.22.22 -udb_test -pdb_test -P2223 -Ddb_test --default-character-set=utf8 -Ne \"$sql\" ","date":"2019-08-17","objectID":"/batch-create-table-mysql/:2:0","tags":["数据库","mysql"],"title":"mysql批量创建表","uri":"/batch-create-table-mysql/"},{"categories":["经验总结"],"content":"一、字节序 字节序，也就是字节的顺序，指的是多字节的数据在内存中的存放顺序。 在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式\u0026x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置 ","date":"2019-07-14","objectID":"/byte-order/:1:0","tags":["软件开发"],"title":"字节序：大端和小端","uri":"/byte-order/"},{"categories":["经验总结"],"content":"二、大端与小端 根据x在连续的4字节内存中存储的顺序，字节序分为大端序（Big Endian） 与 **小端序（Little Endian）**两类，数值0x1234使用两个字节储存：高位字节是0x12，低位字节是0x34 大端序：高位字节在前，低位字节在后，人类读写数值的方法 小端序：低位字节在前，高位字节在后，通常x86架构以小端序存储数据 如图所示： Big Endian 是指低地址端 存放 高位字节。 Little Endian 是指低地址端 存放 低位字节 ","date":"2019-07-14","objectID":"/byte-order/:2:0","tags":["软件开发"],"title":"字节序：大端和小端","uri":"/byte-order/"},{"categories":["经验总结"],"content":"1、为啥有大小端之分？ 答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代性 CPU 内部存储数据；而在其他场景譬如网络传输和文件存储使用大端序。 使用小端序时不移动字节就能改变 number 占内存的大小而不需内存地址起始位。比如我想把四字节的 int32 类型的整型转变为八字节的 int64 整型，只需在小端序末端加零即可。 44 33 22 11 44 33 22 11 00 00 00 00 上述扩展或缩小整型变量操作在编译器层面非常有用，但在网络协议层非也。 在网络协议层操作二进制数字时约定使用大端序，大端序是网络字节传输采用的方式。因为大端序最高有效字节排在首位（低地址端存放高位字节），能够按照字典排序，所以我们能够比较二进制编码后数字的每个字节。 fmt.Println(bytes.Equal([]byte(\"Go\"), []byte(\"Go\"))) // true ","date":"2019-07-14","objectID":"/byte-order/:2:1","tags":["软件开发"],"title":"字节序：大端和小端","uri":"/byte-order/"},{"categories":["经验总结"],"content":"2、为什么要注意字节序? 当程序要与别的程序交互的时候，就涉及到字节序的处理。字节序的处理原则就是 “只有读取的时候，才必须区分字节序，其他情况都不用考虑。” 处理器读取外部数据的时候，必须知道数据的字节序，将其转成正确的值。然后，就正常使用这个值，完全不用再考虑字节序。 即使是向外部设备写入数据，也不用考虑字节序，正常写入一个值即可。外部设备会自己处理字节序的问题。 ","date":"2019-07-14","objectID":"/byte-order/:2:2","tags":["软件开发"],"title":"字节序：大端和小端","uri":"/byte-order/"},{"categories":["经验总结"],"content":"三、网络序和主机序 网络字节序：TCP/IP各层协议将字节序定义为 Big Endian，因此TCP/IP协议中使用的字节序是大端序。 主机字节序：整数在内存中存储的顺序，现在 Little Endian 比较普遍。（不同的 CPU 有不同的字节序） 在进行网络通信时 通常需要调用相应的函数进行主机序和网络序的转换。Berkeley socket API 定义了一组转换函数，用于16和32bit整数在网络序和本机字节序之间的转换。htonl，htons用于本机序转换到网络序；ntohl，ntohs用于网络序转换到本机序。 ","date":"2019-07-14","objectID":"/byte-order/:3:0","tags":["软件开发"],"title":"字节序：大端和小端","uri":"/byte-order/"},{"categories":["经验总结"],"content":"四、各语言关于字节序的处理 ","date":"2019-07-14","objectID":"/byte-order/:4:0","tags":["软件开发"],"title":"字节序：大端和小端","uri":"/byte-order/"},{"categories":["经验总结"],"content":"1、Java JAVA字节序默认是大端序（Big Endian）。由于JVM会根据底层的操作系统和CPU自动进行字节序的转换，所以我们使用java进行网络编程，几乎感觉不到字节序的存在。 import java.nio.ByteBuffer; import java.nio.ByteOrder; import java.util.Arrays; public class JVMEndianTest { public static void main(String[] args) { int x = 0x01020304; ByteBuffer bb = ByteBuffer.wrap(new byte[4]); bb.asIntBuffer().put(x); String ss_before = Arrays.toString(bb.array()); System.out.println(\"默认字节序 \" + bb.order().toString() + \",\" + \" 内存数据 \" + ss_before); bb.order(ByteOrder.LITTLE_ENDIAN); bb.asIntBuffer().put(x); String ss_after = Arrays.toString(bb.array()); System.out.println(\"修改字节序 \" + bb.order().toString() + \",\" + \" 内存数据 \" + ss_after); } } ","date":"2019-07-14","objectID":"/byte-order/:5:0","tags":["软件开发"],"title":"字节序：大端和小端","uri":"/byte-order/"},{"categories":["经验总结"],"content":"2、C++ C/C++ 存储数据时的字节序依赖所在平台的CPU，所以可以通过C/C++程序判定机器的端序： void Endianness() { int a = 0x12345678; if( *((char*)\u0026a) == 0x12) cout \u003c\u003c \"Big Endian\" \u003c\u003c endl; else cout \u003c\u003c \"Little Endian\" \u003c\u003c endl; } ","date":"2019-07-14","objectID":"/byte-order/:6:0","tags":["软件开发"],"title":"字节序：大端和小端","uri":"/byte-order/"},{"categories":["经验总结"],"content":"3、go Go中处理大小端序的代码位于 encoding/binary ,包中的全局变量BigEndian用于操作大端序数据，LittleEndian用于操作小端序数据，这两个变量所对应的数据类型都实行了ByteOrder接口。 package main import ( \"encoding/binary\" \"fmt\" \"unsafe\" ) const INT_SIZE = int(unsafe.Sizeof(0)) //64位操作系统，8 bytes //判断我们系统中的字节序类型 func systemEdian() { var i = 0x01020304 fmt.Println(\"\u0026i:\",\u0026i) bs := (*[INT_SIZE]byte)(unsafe.Pointer(\u0026i)) if bs[0] == 0x04 { fmt.Println(\"system edian is little endian\") } else { fmt.Println(\"system edian is big endian\") } fmt.Printf(\"temp: 0x%x,%v\\n\",bs[0],\u0026bs[0]) fmt.Printf(\"temp: 0x%x,%v\\n\",bs[1],\u0026bs[1]) fmt.Printf(\"temp: 0x%x,%v\\n\",bs[2],\u0026bs[2]) fmt.Printf(\"temp: 0x%x,%v\\n\",bs[3],\u0026bs[3]) } func testBigEndian() { var testInt int32 = 0x01020304 fmt.Printf(\"%d use big endian: \\n\", testInt) var testBytes []byte = make([]byte, 4) binary.BigEndian.PutUint32(testBytes, uint32(testInt)) fmt.Println(\"int32 to bytes:\", testBytes) fmt.Printf(\"int32 to bytes: %x \\n\", testBytes) convInt := binary.BigEndian.Uint32(testBytes) fmt.Printf(\"bytes to int32: %d\\n\\n\", convInt) } func testLittleEndian() { var testInt int32 = 0x01020304 fmt.Printf(\"%x use little endian: \\n\", testInt) var testBytes []byte = make([]byte, 4) binary.LittleEndian.PutUint32(testBytes, uint32(testInt)) fmt.Printf(\"int32 to bytes: %x \\n\", testBytes) convInt := binary.LittleEndian.Uint32(testBytes) fmt.Printf(\"bytes to int32: %d\\n\\n\", convInt) } func main() { systemEdian() fmt.Println(\"\") testBigEndian() testLittleEndian() } 输出： \u0026i: 0xc00000a0b8 system edian is little endian temp: 0x4,0xc00000a0b8 temp: 0x3,0xc00000a0b9 temp: 0x2,0xc00000a0ba temp: 0x1,0xc00000a0bb 16909060 use big endian: int32 to bytes: [1 2 3 4] int32 to bytes: 01020304 bytes to int32: 16909060 1020304 use little endian: int32 to bytes: 04030201 bytes to int32: 16909060 ","date":"2019-07-14","objectID":"/byte-order/:7:0","tags":["软件开发"],"title":"字节序：大端和小端","uri":"/byte-order/"},{"categories":["经验总结"],"content":"五、参考文章 理解字节序 golang之大端序、小端序 字节序及 Go encoding/binary 库 字节顺序 ","date":"2019-07-14","objectID":"/byte-order/:8:0","tags":["软件开发"],"title":"字节序：大端和小端","uri":"/byte-order/"},{"categories":["经验总结"],"content":"go语言解析 map[string]interface{} 数据格式的注意事项： map记得分配内存 解析出来的int类型会变成float64类型 注意判断不为nil后再转换类型 示例代码： package main import ( \"fmt\" \"encoding/json\" ) func main() { var m map[string]interface{} //声明变量，不分配内存 m = make(map[string]interface{}) //必可不少，分配内存 m[\"name\"] = \"saul\" var age int = 20 m[\"age\"] = age m[\"nation\"] = \"China\" print_map(m) fmt.Println(\"==============\") data, err:=json.Marshal(m) if err != nil { } fmt.Println(\"err:\", err) fmt.Println(data) fmt.Println() m1 := make(map[string]interface{}) err = json.Unmarshal(data, \u0026m1) fmt.Println(\"err:\", err) fmt.Println(m1) print_map(m1) fmt.Println() if m1[\"name\"]!= nil { fmt.Println(m1[\"name\"].(string)) } if m1[\"type\"]!= nil { fmt.Println(m1[\"type\"].(string)) } else { fmt.Println(\"there is not the key of type\") } } //解析 map[string]interface{} 数据格式 func print_map(m map[string]interface{}) { for k, v := range m { switch value := v.(type) { case nil: fmt.Println(k, \"is nil\", \"null\") case string: fmt.Println(k, \"is string\", value) case int: fmt.Println(k, \"is int\", value) case float64: fmt.Println(k, \"is float64\", value) case []interface{}: fmt.Println(k, \"is an array:\") for i, u := range value { fmt.Println(i, u) } case map[string]interface{}: fmt.Println(k, \"is an map:\") print_map(value) default: fmt.Println(k, \"is unknown type\", fmt.Sprintf(\"%T\", v)) } } } 结果： name is string saul age is int 20 nation is string China ============== [123 34 97 103 101 34 58 50 48 44 34 110 97 109 101 34 58 34 115 97 117 108 34 44 34 110 97 116 105 111 110 34 58 34 67 104 105 110 97 34 125] ============== age is float64 20 name is string saul nation is string China ============== saul there is not the key of type ","date":"2019-05-14","objectID":"/parsing-mapstringinterface-data-format-for-go/:0:0","tags":["go"],"title":"go语言解析map[string]interface{}的注意事项","uri":"/parsing-mapstringinterface-data-format-for-go/"},{"categories":["经验总结"],"content":"1. Kilim中的Task，即用户线程如何调度和切换？ 相比传统的Thread多线程间抢占式调度，Kilim中的Task采用的是协作式调度，即由Task本身负责释放和恢复占用CPU 在多任务的调度上操作系统采取抢占式和协作式两种方式。 ","date":"2019-02-03","objectID":"/question-about-kilim/:1:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"2.Kilim如何识别线程堆栈中哪些方法是Pauseable，即可暂停的？ Kilim通过代码编译期识别抛出的Pauseable异常注解，来判断识别方法可暂停 ","date":"2019-02-03","objectID":"/question-about-kilim/:2:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"3.Kilim是如何实现线程执行过程中当前方法的暂停和恢复？ Kilim通过编译期字节码编织，对每一个可暂停的方法进行字节码处理，在方法执行前和执行后加上相关的执行上下文的处理，暂停时会保存整个线程堆栈，包括完整栈帧，程序计数器等等，然后通过特定的字节码跳转指令jsr跳转到另外一个Task的执行方法中，恢复时将复原整个线程堆栈，包括完整栈帧，程序计数器等等，回到上次暂停时的指令地址处继续执行。 ","date":"2019-02-03","objectID":"/question-about-kilim/:3:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"4.Kilim中的Weaver工具是如何针对编译的代码实现织入的？ 字节码技术，具体来说通过ASM字节码框架实现对class文件的重写 ","date":"2019-02-03","objectID":"/question-about-kilim/:4:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"5.如何将一个传统的线程执行方法改造成Kilim的Task模型？ Kilim通过编译期字节码编织，对每一个可暂停的方法进行字节码处理，在方法执行前和执行后加上相关的执行上下文的处理： 首先需要实现一个类继承Task，实现Task的execute方法，业务逻辑不再放在线程的run方法体体，而是放在Task的execute方法体中。 execute方法中调用的方法如果是可能暂停的，则必须声明抛出Pauseable异常，否则可以不需要抛出。 Task之间的通信通过Mailbox邮箱来传递消息，put和get时存在三种版本，包括阻塞线程，阻塞Task但不阻塞线程，非阻塞。 针对这些Task和Pauseable方法编译时，需要使用Kilim提供的Weaver工具进行编织处理，如果不进行编织处理，运行时将会异常。 对于Kilim中的方法需要注意，一个Pauseable方法只能被另一个Pauseable方法调用。 ","date":"2019-02-03","objectID":"/question-about-kilim/:5:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"6. Kilim中哪些操作可以使得Task暂停或者恢复运行？ Kilim中常用有以下方法暂停、恢复Task的运行： Task.sleep()能使当前Task暂停运行一段时间 Task.yield()能使当前Task暂停放弃运行 Task.pause()能使当前Task暂停执行 Task.resume()能使当前Task恢复执行 Mailbox.get()能使当前Task暂停执行直到Mailbox队列非空。 ","date":"2019-02-03","objectID":"/question-about-kilim/:6:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"7. Kilim中Task占用的内存有多大？ 一个Task所占用的内存包括以下部分： Task的具体实现类实例本身占用的内存 Task之间通信依赖的Maibox的内容占用的内存 如果Task暂停，那么Task函数调用链上的函数栈帧数组需要保存到Fiber中，不过Kilim的Weaver工具在代码编译期间将分析代码控制流程、有用的变量、常量等，保证只保存在后续Task恢复执行时需要用到的数据。 ","date":"2019-02-03","objectID":"/question-about-kilim/:7:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"8. Kilim中Fiber的作用 Fiber主要作用用来管理和保存Task执行过程中调用层次中的函数栈帧的状态，这里的函数栈帧与JVM运行时中的函数栈帧是相同含义，但是Fiber不会将函数栈帧中的全部信息原封不动的镜像拷贝一份，比如局部变量表中的所有变量，而是经过代码分析之后有选择的暂存有必要保留的变量，一般只需要保存后续执行流程中需要用到的变量，例如静态常量等就无需保存到Fiber中，因为静态变量可以直接通过iconst之类的字节码直接加载到操作数栈。 ","date":"2019-02-03","objectID":"/question-about-kilim/:8:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"9. Kilim中Fiber中的pc的真正含义？ Fiber中的pc，字面意义是指程序计数器，实际含义是：如果pc值为0，则表示第一次开始执行，程序执行流程和字节码增强前的流程是一样的；如果pc值为N，则表示直接跳转至本函数中第N个Pauseable方法处开始执行，说明之前执行到第N个Pauseable方法时暂停了，此时Task恢复执行，字节码层面通过tableswitch指令将直接跳转该Pauseable方法处执行，也即再次进入该函数执行体。以此类推，整个函数调用链均按照这种逻辑流转。 public void function() throw Pauseable { XXX; // 临时变量等初始化 A(); // function A is pauseable，如果执行到函数A 暂停了，则pc=1 B(); // function B is pauseable，如果执行到函数B暂停了，则pc=2，下次恢复时从function()函数入口直接跳转到这里，执行函数B C(); // function C is pauseable，如果执行到函数B暂停了，则pc=3，下次恢复时从function()函数入口直接跳转到这里，执行函数C } ","date":"2019-02-03","objectID":"/question-about-kilim/:9:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"10. Kilim中Fiber中State的作用？ Fiber中的State作用主要体现在curState和stateStack两个变量，它们用来维护函数调用链执行过程中的函数栈帧。 当Task将要执行某个Pauseable方法时，将首先调用Fiber的down方法，来记录当前执行到整个函数调用链中的下一层次，并记录curState和pc。 当Task在执行某个Pauseable方法过程中暂停时，内部会调用Task的pause方法，而pause直接调用togglePause方法，这个方法会根据curState是否为null，来设置Fiber的isPausing的值，而isPausing表示Task是暂停还是恢复，相应源码如下： if (curState == null) { setState(PAUSE_STATE); } else { stateStack[iStack] = null; isPausing = false; } 当Task执行完某个Pauseable方法时，将会调用Fiber的up方法，标识调用某个Pauseable方法返回，且up方法的返回值表示该Pauseable方法是正常返回还是暂停返回，因为up方法内部会根据Fiber中的isPausing变量值和本函数栈帧stateStack[iStack]是否为null来判断是否暂停，以及函数栈帧是否已经保存。如果是PAUSING__NO_STATE，说明被调函数暂停，本函数还未保存栈帧，则需要将本函数栈帧，一般后续执行需要使用到的变量（包括函数实参、函数局部变量）保存到State中，也即 stateStack[iStack]， /* * Status indicators returned by down() * * normal return, nothing to restore */ public static final int NOT_PAUSING__NO_STATE = 0; /* * Normal return, have saved state to restore before resuming */ public static final int NOT_PAUSING__HAS_STATE = 1; /* * Pausing, and need to save state before returning */ public static final int PAUSING__NO_STATE = 2; /* * Pausing, and have saved state from an earlier invocation, * so nothing left to do. */ public static final int PAUSING__HAS_STATE = 3; ","date":"2019-02-03","objectID":"/question-about-kilim/:10:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"11.什么场景下适合做Kilim协程？ IO密集型的应用比较适合使用协程，比如应用中存在较多的与后端的网络交互，存在较多的时间在等待后端响应,可以保证线程不会阻塞在等待网络响应，充分利用多核多线程的能力。而对于CPU密集型应用，由于大部分情况CPU都比较繁忙，Kilim反而不会产生很好的作用。 ","date":"2019-02-03","objectID":"/question-about-kilim/:11:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"12.Kilim中Task的工作机制？ Actor采取的这种类似消息机制的方式，实际在守护线程和外部线程之间有一个队列，俗称信箱，外部线程只要把请求放入，守护线程就读取进行处理。这种异步高效方式是Actor基本原理。Task 是轻量型的线程，它们通过 Kilim 的 Mailbox 类型与其他 Task 通信。 ","date":"2019-02-03","objectID":"/question-about-kilim/:12:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"13.Kilim框架做了什么？ 利用字节码增强(基于ASM字节码框架)，将普通代码转化为支持协程的代码； 调用pausable的时候，如果pause了就保存当前方法栈的State，停止执行，将控制权交给调度器； 调度器负责协调就绪的协程； 协程resume的时候，自动恢复State，回复到上次执行的位置继续执行 ","date":"2019-02-03","objectID":"/question-about-kilim/:13:0","tags":["协程","java"],"title":"kilim疑问解答","uri":"/question-about-kilim/"},{"categories":["经验总结"],"content":"0、背景 ​ 近年来由于一批新兴的语言的流行，存在已久的协程也焕发出新的青春。类似Lua、Go、Phthon等语言都原生支持协程，而传统的C语言中，C标准库里 的函数setjmp和longjmp可以用来实现协程，另外一种广为使用的C语言协程非标准库则是 ucontext组件。由于协程在Java语言层面原生不支持，因此在Java中如果要使用协程，则需要使用第三方的协程框架。Kilim正是这样一个比 较著名的Java 协程开源库。 ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:1:0","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"1、kilim是什么 Kilim是一个Java的actor框架，由剑桥的博士sriram srinivasan开发的一个用于在Java中使用Coroutine的框架。它由一个字节码后处理器(“ weaver”)、一个带缓冲邮箱(多生产者、单消费者队列)的运行时库、一个用户级调度器组成。 ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:2:0","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"2、Kilim协程框架图 Kilim协程框架的整体结构图如下，包括的核心组件：Scheduler协程调度器，WorkerThread工作者线程，Task任务，Mailbox消息邮箱队列，Fiber协程上下文。 ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:3:0","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"1、Task Task对象是Kilim中核心的结构，所有业务的逻辑代码都是在Task中执行。Task可以理解为Actor模型中的Actor，Task的执行过程 中可以被暂停，也可以被再次唤醒。使用方式上与Thread 基本类似，启动需要调用Task的start 方法。 public Task start() { if (scheduler == null) { setScheduler(Scheduler.getDefaultScheduler()); } resume(); return this; } ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:3:1","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"2、 Scheduler Scheduler是Kilim框架中核心的任务调度器，负责管理任务的工作者线程WorkerThread，以及一个基本的FIFO队列，维护着 Task任务列表，Scheduler负责分派Task给指定的工作者线程WorkerThread执行，其实现上类似于ExecutorService 线程池管理Runnable和Callable任务的执行。工作者线程WorkerThread的默认初始化个数为CPU核数，且所有空闲的线程会添加到 RingQueue队列中。 public LinkedList\u003cWorkerThread\u003e allThreads = new LinkedList\u003cWorkerThread\u003e(); public RingQueue\u003cWorkerThread\u003e waitingThreads = new RingQueue\u003cWorkerThread\u003e(10); protected volatile boolean shutdown = false; public RingQueue\u003cTask\u003e runnableTasks = new RingQueue\u003cTask\u003e(100); ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:3:2","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"3、WorkerThread WorkerThread是执行任务Task的具体线程，内部维护一个默认大小为10的环形队列RingQueue，与ThreadPoolExecutor线程池中定义的Worker类似，循环阻塞式的从任务队列中获取下一个任务执行。 RingQueue\u003cTask\u003e tasks = new RingQueue\u003cTask\u003e(10); public void run() { try { while (true) { Task t = getNextTask(this); // blocks until task available runningTask = t; t._runExecute(this); runningTask = null; } } catch (ShutdownException se) { // nothing to do. } catch (OutOfMemoryError ex) { System.err.println(\"Out of memory\"); } catch (Throwable ex) { ex.printStackTrace(); } runningTask = null; } ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:3:3","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"4、RingQueue RingQueue本质上即一个环形队列，作为Queue用于不同的线程之间传递message的设计，和ZeroMQ利用ringbuffer来作为pipe在不同线程之间传递message的用法都是很类似的 public class RingQueue\u003cT\u003e { protected T[] elements; protected int iprod;// producer index protected int icons;// consumer index protected int maxSize; protected int size; ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:3:4","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"5、 Mailbox Kilim 中通过Mailbox 对象来发送消息，Mailbox 的基本原则为可以有多个消息发送者，但只能有一个消息接收者，发送的方式有同步发送、异步发送和阻塞线程方式的同步发送三种： 同步发送是指保证一定能将消息放入发送队列中，如当前发送队列已满，则等待到可用为止，阻塞的为当前Task； 异步发送则是尝试将消息放入发送队列一次，如果发送失败，则返回false，成功则返回true，不会阻塞Task； 阻塞线程方式的同步发送是指阻塞当前线程，并保证将消息发送给接收者。 public class Mailbox\u003cT\u003e implements PauseReason, EventPublisher { T[] msgs; private int iprod = 0; // producer index private int icons = 0; // consumer index; private int numMsgs = 0; private int maxMsgs = 300; EventSubscriber sink; } 与发送消息类似，Kilim 中也通过Mailbox 来接收消息，接收方式有同步接收、异步接收以及阻塞线程方式的同步接收三种： 同步接收是指阻塞当前Task，直到接收到消息才返回； 异步接收是指立刻返回Mailbox 中的消息，有就返回，没有则返回null； 阻塞线程方式的同步接收是指阻塞当前线程，直到接收到消息才返回。 ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:3:5","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"6、Fiber Fiber的概念可能稍微难以理解，Kilim中的Fiber对象主要用来维护Task执行过程中的堆栈，Fiber中的主要成员变量有 curState，pc，stateStack，iStack等，其中curState为当前协程的执行状态，stateStack为协程的堆 栈，iStack表示当前的栈帧位置。 public final class Fiber { public State curState; public int pc; /* * One State object for each activation frame in the call hierarchy. */ private State[] stateStack = new State[10]; /* * Index into stateStack and equal to depth of call hierarchy - 1 */ private int iStack = -1; /* * The task to which this Fiber belongs */ public Task task; } ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:3:6","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"3、kilim的调度流程 调度流程中有三个主要的类 Scheduler-调度器 WorkThread-调度运行承载线程 Task-类似于Thread，协程的体现者 ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:4:0","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"4、Kilim要解决的问题 Kilim协程框架中最核心需要解决的问题 如何暂停处理当前任务，转而处理其他任务？ 如何恢复任务继续执行？ 也即如何实现协程本身的 yield / resume的语义特性。 ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:5:0","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"Kilim的解决方案 Kilim框架在实现yield / resume的语义特性时，主要做以下几个事情： 利用字节码技术(基于ASM字节码框架)，将普通代码转化为支持协程的代码； 调用Pauseable方法的时候，如果方法暂停了就保存当前方法的堆栈，暂停执行当前Task，将控制权交给Scheduler调度器； Scheduler调度器负责协调其他就绪的Task； 之前暂停的Task恢复的时候，自动恢复对应方法的堆栈，恢复到上次执行的位置继续执行； ​ 其中，第一点是在编译期实现，后面三点是在运行期执行。再稍微详细一点就是：Kilim通过编译期字节码编织，对每一个可暂停（Pauseable）的方 法进行字节码处理，在方法执行前和执行后加上相关的执行上下文的处理，暂停时会保存执行堆栈，然后通过特定的字节码跳转指令goto跳转到另外一个 Task的执行方法中，恢复时将复原整个线程堆栈，回到上次暂停时的位置继续往下执行。 ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:5:1","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"5、Kilim的工作原理 Kilim最神奇的地方在于字节码增加，那么它是怎样将普通的Java代码改写层支持协程的代码呢？首先上Kilim官方文档中的一张图： 这张图也即Kilim实现协程语义的精髓所在，和C语言中实现协程的方式有很大不同，接下来仔细分析。 ​ 左边是普通的Java函数代码，与我们常见的函数唯一有所不同的是函数a和b均显示声明抛出Pausable异常，而实际上这个异常在运行期间不会抛出， 它的实际作用类似于注解，使得Kilim能够识别哪些代码需要Weaver工具进行代码增强。函数抛出Pausable异常即表明该函数是可暂停的， 右边的代码即通过字节码增强后的代码，与左边原始的代码相比，首先函数声明中额外增加了一个Fiber参数，Fiber可以理解为当前纤程、协程的上下 文。Fiber中存储着协程暂停和恢复时需要用到的函数堆栈、程序计数器以及当前函数的执行状态。字节码增强后的代码以调用Pausable方法a为分 界，将整个函数分成几个代码块，也即官网文档中提及的prelude、pre_call、post_call三部分。 在prelude块中，也即刚进入函数a时将会执行的代码块，将根据Fiber中的pc程序计数器跳转到对应的代码块处开始执行。 在pre_call块中，也即在调用函数b之前，将调用Fiber的down方法记录当前执行状态和pc程序计数器，标识着函数将进入下一个Pausable方法。 在post_call块中，也即在调用函数b之后，将调用Fiber的up方法计算函数b调用完成后返回的状态，标识着从一个被调的Pausable方法返回，它既可能是正常的函数b执行完成返回，也可能是函数b执行暂停返回，接着通过这个状态控制后续的执行流程。 这四种状态分别为： NOT_PAUSING__NO_STATE，即被调函数执行完成正常返回，这种情况与即普通的函数执行类似。 NOT_PAUSING__HAS_STATE，即被调函数执行完成，但还存在上次暂存的栈帧，这种情况一般是函数从上次暂停处恢复执行，且顺利执行完成返回，此时需要恢复函数的栈帧，然后goto到RESUME代码块继续执行。 PAUSING__NO_STATE，即被调函数执行过程中暂停，且还未保存函数栈帧，需要主调函数执行暂存操作，这种情况一般即第一次协程执行到需要暂停处，此时需要采用字节码暂存函数的栈帧和状态，然后直接return。 PAUSING__HAS_STATE， 即被调函数执行过程中暂停，且已经保存函数栈帧，这种情况是该Pausable从上次暂停处恢复执行，但是依然没有预期的结果，需要再次暂停，此时因为之 前暂停时函数栈帧和状态都已经保存过，不需要再做什么，因此直接return即可。 ​ OK，到目前为止基本原理大概清晰，不过要把协程与线程的执行过程整个串联起来，形成一个整体还稍显迷惑，接下来详细说明。 上面已经提到协程执行过程中核心的两个点：一点是调用Pauseable方法的时候，如果暂停了就保存当前方法栈的State，暂停执行当前Task，将 控制权交给Scheduler调度器，另外一点是暂停的Task恢复的时候，自动恢复State，恢复到上次执行的位置继续执行。这两点的具体过程如下： 前面的Kilim结构图中已经讲到Kilim中有几个核心元素，包括Task、Scheduler、WorkerThread以及Mailbox。其中 WorkerThread即实际执行Task任务的工作者线程，Task即具体的可暂停的业务逻辑，Task与Task之间通过参数化定制的 Mailbox来通信。Kilim将线程run方法体中所有嵌套层级调用的所有Pausable方法组织成一个具有父子关系的调用链，形如 run-\u003eA-\u003eB-\u003eC，通过Task私有的Fiber来记录执行到哪一个层级。通常Kilim中使用Mailbox提供的get、 getb、getnb三个不同版本来接收消息，其中最常用的get会阻塞当前Task而不阻塞当前线程。 ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:6:0","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"如何实现Task的暂停？ 例如一个运行状态Task的调用链run-\u003eA-\u003eB-\u003eC，其中A、B、C均为Pauseable方法，在函数C中调用了 Mailbox的get方法且设置了超时时长，当整个链嵌套执行到C的get方法这一行时，因为get本身也是一个Pausable方法，如果没有接收到 消息，将会把Task作为该Mailbox的观察者，并调用Task.pause(this)方法暂停自身，然后该get方法即直接返回，get调用返回 后，C根据Fiber的up计算发现是暂停返回，则也暂停本函数，暂存栈帧和状态，直接返回，如此逆向直到run方法，从而实现Task的暂停。 public T get() throws Pausable{ Task t = Task.getCurrentTask(); T msg = get(t); while (msg == null) { Task.pause(this); removeMsgAvailableListener(t); msg = get(t); } return msg; } ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:6:1","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"如何实现Task的恢复呢？ Task暂停的过程中有一步很关键，将该Task作为该Mailbox的观察者，在当有其他线程把消息通过调用Mailbox的put方法添加到Mailbox中时，或者超时定时器触发时，将会回调该Mailbox的观察者，告诉观察者有新的消息到来。这样Task的onEvent被回调，onEvent直接调用resume方法，而resume方法实际最重要的一步即调用Scheduler的schedule方法，将该Task加入到Scheduler的可运行任务队列中，并随机选择一个等待运行的工作者线程，并notify该线程，该线程被唤醒后将执行该Task，重复之前的函数调用链run-\u003eA-\u003eB-\u003eC执行，由于A、B、C三个函数中均已经保存了之前暂停的函数栈帧和状态，因此之前已经执行过的代码块将不会重复执行，会根据Fiber中状态选择性的执行对应的代码块。因为Mailbox中已经有消息，因此再重复执行到get方法时能够直接获取到消息，正常的往下继续执行。这样相当于又走了一次调用链，但是并非重复执行已经执行过的代码，而是恢复执行之前未执行的代码，从而实现Task的恢复 public void onEvent(EventPublisher ep, Event e) { resume(); } ","date":"2019-02-02","objectID":"/simple-analysis-kilim/:6:2","tags":["协程","java"],"title":"浅谈Java协程开源库---kilim","uri":"/simple-analysis-kilim/"},{"categories":["经验总结"],"content":"之前使用eclipse，可以在一个窗口打开多个maven工程。后来换成使用idea，发现idea默认一个窗口打开一个工程project。有时候项目多了，想在一个idea界面打开多个互不相关的maven工程。 在 IntelliJ IDEA 中，没有类似于 Eclipse 工作空间（Workspace）的概念，而是提出了Project和Module这两个概念。 在 IntelliJ IDEA 中Project是最顶级的结构单元，然后就是Module，一个Project可以有多个Module。目前，主流的大型项目结构基本都是多Module的结构，这类项目一般是按功能划分的，比如：user-core-module、user-facade-module和user-hessian-module等等，模块之间彼此可以相互依赖。通过这些Module的命名可以看出，它们都是处于同一个项目中的模块，彼此之间是有着不可分割的业务关系的。 因此，我们可以大致总结出：一个Project是由一个或多个Module组成，尽量让各模块处于同一项目之中，此时彼此之间具有互相依赖的关联关系。在这里，之所以说“尽量”，是因为 IntelliJ IDEA 的Project是一个没有具备任何编码设置、构建等开发功能的，主要起到一个项目定义、范围约束、规范类型的效果，或许，我们也可以简单地理解Project就是一个单纯的目录，只是这个目录在命名上必须有其代表性的意义。在一般情况下，IntelliJ IDEA 是默认单Project单Module的，这时Project和Module合二为一，在没有修改存储路径的时候，显然Project对Module具有强约束作用啦！不过说实话，这里就是将Module的内容放在了Project的目录下，实际上还是Module自己约束自己。 原文：https://blog.csdn.net/qq_35246620/article/details/65448689 根据上述理解，可以将多个maven工程作为module导入到idea的project中。idea中的project类比eclipse的workspace。idea中的module类比eclipse的project。 1、open多个maven工程所在的目录 2、然后选择要添加的module: File-\u003eProject Structure…-\u003eModules可以添加Modules 3、选择maven工程导入，一路确认，最后就成功在idea一个界面导入多个maven工程 这几个maven工程并无相关性，只是为了和eclipse的workspace类比，减少多个工程之间切换idea界面的麻烦。 ","date":"2019-01-28","objectID":"/open-multi-module-in-one-project-for-idea/:0:0","tags":["idea"],"title":"idea中一个窗口引入多个maven project工程","uri":"/open-multi-module-in-one-project-for-idea/"},{"categories":["经验总结"],"content":"1、 打开settings设置 2、 选择keymap 3、 如果是window版本的话，搜索show explorer，右键设置快捷键，通常我设置为Alt + e 键；如果是mac版本的话，搜索file path，默认快捷键是option + command + F12，也可以自己重新定义过一个快捷键，例如：option + E 键。 到此，就可以通过快捷键快速打开文件所在的文件夹了。 PS：很多快捷键都可以通过keymap找到，如果没有，也可以通过keymap设置。熟练使用快捷键，远离鼠标，效率UP ","date":"2019-01-27","objectID":"/open-the-folder-in-idea/:0:0","tags":["idea"],"title":"在IntelliJ idea中快速打开文件所在的文件夹的解决办法","uri":"/open-the-folder-in-idea/"},{"categories":["算法"],"content":" 反转一个单链表。 示例: 输入: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003eNULL 输出: 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003eNULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ ","date":"2018-11-05","objectID":"/leetcode-206-reverse-linked-list/:0:0","tags":["leetcode","链表"],"title":"LeetCode 206 Reverse Linked List（反转链表)","uri":"/leetcode-206-reverse-linked-list/"},{"categories":["算法"],"content":"解法一：迭代法 利用一个哑节点，来依次反转节点 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { if(head == null || head.next == null) { return head; } ListNode dummyNode = null; while(head != null) { ListNode next = head.next; //暂存下一个待遍历节点 head.next = dummyNode; //当前到的当前节点指向新的链表头 dummyNode = head; //更新 新的链表头 head = next; //迭代下一个节点 } return dummyNode; } } ","date":"2018-11-05","objectID":"/leetcode-206-reverse-linked-list/:1:0","tags":["leetcode","链表"],"title":"LeetCode 206 Reverse Linked List（反转链表)","uri":"/leetcode-206-reverse-linked-list/"},{"categories":["算法"],"content":"解法二：递归 递归法本质是一种不断分解问题规模的思想，子问题除了规模更小之外，其他和父问题都一样。递归主要是找到递归公式和终止条件。 现在需要把A-\u003eB-\u003eC-\u003eD进行反转， 可以先假设B-\u003eC-\u003eD已经反转好，已经成为了D-\u003eC-\u003eB,那么接下来要做的事情就是将D-\u003eC-\u003eB看成一个整体，让这个整体的next指向A，所以问题转化了反转B-\u003eC-\u003eD。 那么，可以先假设C-\u003eD已经反转好，已经成为了D-\u003eC, 那么接下来要做的事情就是将D-\u003eC看成一个整体，让这个整体的next指向B，所以问题转化了反转C-\u003eD。 那么,可以先假设D(其实是D-\u003eNULL)已经反转好，已经成为了D(其实是head-\u003eD),那么接下来要做的事情就是将D(其实是head-\u003eD)看成一个整体，让这个整体的next指向C，所以问题转化了反转D。 public ListNode reverseList(ListNode head) { if (head == null || head.next == null) { //链表为空直接返回，而head.next为空是递归终止条件 return head; } //一直循环到链尾，返回的newHead即为旧链表尾部，新的链表头 ListNode newHead = reverseList(head.next); head.next.next = head; //翻转链表的指向，形成一个环，例如：由4-\u003e5变成一个环，4指向5，5也指向4 head.next = null; //赋值NULL，将上一步形成的链表环切掉，防止链表错乱 return newHead; //新链表头永远指向的是原链表的链尾 } head.next.next = head 表示head的下一个节点翻转指向自己head，形成一个环，head.next = null 表示切断之前的链接方向，避免环路。 ","date":"2018-11-05","objectID":"/leetcode-206-reverse-linked-list/:2:0","tags":["leetcode","链表"],"title":"LeetCode 206 Reverse Linked List（反转链表)","uri":"/leetcode-206-reverse-linked-list/"},{"categories":["分布式"],"content":"前言 面对大量用户访问、高并发请求，海量数据，可以使用高性能的服务器、大型数据库，存储设备，高性能Web服务器，当单机容量达到极限时，我们需要考虑业务拆分和分布式部署，来解决大型网站访问量大，并发量高，海量数据的问题。 从单机网站到分布式网站，很重要的区别是业务拆分和分布式部署，将应用拆分后，部署到不同的机器上，实现大规模分布式系统。分布式和业务拆分解决了，从集中到分布的问题，但是每个部署的独立业务还存在单点的问题和访问统一入口问题，为解决单点故障，我们可以采取冗余的方式。将相同的应用部署到多台机器上。解决访问统一入口问题，我们可以在集群前面增加负载均衡设备，实现流量分发。 ","date":"2018-09-28","objectID":"/load-balance/:1:0","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"一、什么是负载均衡 引用自维基百科的定义： 负载平衡（Load balancing）是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行,用于解决互联网架构中的高并发和高可用的问题。 通俗的讲，就是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。 ","date":"2018-09-28","objectID":"/load-balance/:2:0","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"二、负载均衡原理 系统的扩展可分为纵向（垂直）扩展和横向（水平）扩展。纵向扩展，是从单机的角度通过增加硬件处理能力，比如CPU处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升，不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。因此需要采用横向扩展的方式，通过添加机器来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。这就是典型的集群和负载均衡架构：如下图： 客户端的流量首先会到达负载均衡服务器，由负载均衡服务器通过一定的调度算法将流量分发到不同的应用服务器上面，同时负载均衡服务器也会对应用服务器做周期性的健康检查，当发现故障节点时便动态的将节点从应用服务器集群中剔除，以此来保证应用的高可用。 ","date":"2018-09-28","objectID":"/load-balance/:3:0","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"负载均衡的作用： 高并发，解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）； HTTP缓存。负载均衡器可以存储静态内容，当用户请求它们时可以直接响应用户而不必再向后台服务器请求。 健康检查。负载均衡器可以检查后台服务器应用层的健康状况并从服务器池中移除那些出现故障的服务器。 故障转移，提供故障转移，实现高可用； 安全防护；（负载均衡设备上做一些过滤，黑白名单等处理） ","date":"2018-09-28","objectID":"/load-balance/:3:1","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"三、负载均衡分类 负载均衡根据所采用的设备对象（软/硬件负载均衡），应用的OSI网络层次（网络层次上的负载均衡），及应用的地理结构（本地/全局负载均衡）等来分类。 ","date":"2018-09-28","objectID":"/load-balance/:4:0","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"1、DNS负载均衡 DNS（Domain Name System）负责域名解析的服务，域名url实际上是服务器的别名，实际映射是一个IP地址，解析过程，就是DNS完成域名到IP的映射。而一个域名是可以配置成对应多个IP的。因此，DNS也就可以作为负载均衡服务。 DNS 是最简单也是最常见的负载均衡方式，一般用来实现地理级… 优点: 使用简单：负载均衡工作，交给DNS服务器处理，省掉了负载均衡服务器维护的麻烦 提高性能：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址，可以加快访问速度，改善性能； 缺点: 可用性差：DNS解析是多级解析，新增/修改DNS后，解析时间较长；解析过程中，用户访问网站将失败； 扩展性低：DNS负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展； 维护性差：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载） 应用场景: ​ 一般互联网web网站讲DNS作为第一级负载均衡，记录对应着内部负载均衡的IP地址，通过内部负载均衡将请求分发到真实的Web服务器上。 ","date":"2018-09-28","objectID":"/load-balance/:4:1","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"2、IP负载均衡（四层负载均衡 L4） 四层负载均衡工作在OSI模型的传输层，主要工作是转发，它在接收到客户端的流量以后通过修改数据包的地址信息（IP+Port）将流量转发到应用服务器。常见的负载均衡方式，是LVS（Linux Virtual Server，Linux虚拟服务），通过IPVS（IP Virtual Server，IP虚拟服务）来实现。有NAT, TUN（IP隧道）,DR（三角传输）三种请求转发模式。三者有一定区别，限于篇幅，后面再另外阐述。 优点： 在内核进程完成数据分发，比在应用层分发性能更好； 四层LB对于应用侵入比较小，对应用的感知较少，应用接入基本不需要针对LB做任何的代码改造。 缺点： 所有请求响应都需要经过负载均衡服务器，集群最大吞吐量受限于负载均衡服务器网卡带宽； 没法对业务流量进行细粒度的调控 ","date":"2018-09-28","objectID":"/load-balance/:4:2","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"3、反向代理负载均衡 （七层负载均衡 L7） 七层负载均衡工作在OSI模型的应用层，因为它需要解析应用层流量，所以七层负载均衡在接到客户端的流量以后，还需要一个完整的TCP/IP协议栈。七层负载均衡会与客户端建立一条完整的连接并将应用层的请求流量解析出来，再按照调度算法选择一个应用服务器，并与应用服务器建立另外一条连接将请求发送过去。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接，本质上是一个代理服务器，因此七层负载均衡的主要工作就是代理。 常见实现七层负载均衡的软件有：nginx、haproxy、Mysql proxy 在四层负载均衡的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。 七层负载均衡分析应用层的信息，如HTTP协议URI或Cookie信息，实现七层负载均衡。此种负载均衡器能理解应用协议。 优点： 七层负载均衡结合一些通用的业务流量负载逻辑和容灾逻辑可做成很细致的负载均衡和流量导向方案 使整个网络更“智能化”，能把对图片类的请求转发到图片服务器，对文字的请求转发到文字服务器 可以有效防止 SYN Flood攻击，使网站更安全 缺点： 七层负载均衡一般对应用本身的感知比较多，一般接入七层负载均衡时，应用需要配合做相应的改造。 4层和7层负载均衡区别 主要在协议和灵活性，Nginx支持应用层协议，如http、e-mail协议，而lvs是4层负载均衡，与协议无关，所有应用都支持。4层负载架构设计比较简单，无需解析具体的消息内容，在网络吞吐量及处理能力上会相对比较高，而7层负载均衡的优势则体现在功能多，控制灵活强大。在具体业务架构设计时，使用七层负载或者四层负载还得根据具体的情况综合考虑。 举个例子形象的说明：四层负载均衡就像银行的自助排号机，每一个达到银行的客户根据排号机的顺序，选择对应的窗口接受服务；而七层负载均衡像银行大堂经理，先确认客户需要办理的业务，再安排排号。这样办理理财、存取款等业务的客户，会根据银行内部资源得到统一协调处理，加快客户业务办理流程。 四层负载均衡（layer 4） 七层负载均衡（layer 7） 基于 基于IP+Port的 基于虚拟的URL或主机IP等 类似于 路由器 代理服务器 握手次数 1 次 2 次 性能 高；无需解析内容 中；需要算法识别 URL，Cookie 和 HTTP head 等信息 安全性 低，无法识别 DDoS等攻击 高， 可以防御SYN cookie以SYN flood等 额外功能 无 会话保持，图片压缩，防盗链等 ","date":"2018-09-28","objectID":"/load-balance/:4:3","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"4、硬件负载均衡 硬件负载均衡是通过单独的硬件设备来实现负载均衡功能，这类设备和路由器、交换机类似，可以理解为一个用于负载均衡的基础网络设备。目前业界典型的硬件负载均衡设备有两款：F5 和 A10。这类设备性能强劲、功能强大，但价格都不便宜，普通业务量级的公司一是负担不起，二是业务量没那么大，用这些设备也是浪费。 优点： 功能强大：全面支持各层级的负载均衡，支持全面的负载均衡算法，支持全局负载均衡。 性能强大：软件负载均衡支持到 5万级并发已经很厉害了，硬件负载均衡可以支持 100 万以上的并发。 稳定性高：商用硬件负载均衡，经过了良好的严格测试，经过大规模使用，稳定性高。 支持安全防护：硬件均衡设备除具备负载均衡功能外，还具备防火墙、防 DDoS 攻击等安全功能。 缺点： 价格昂贵，F5 价格：15w~55w不等；A10 价格：55w-100w不等； 扩展能力差，硬件设备，可以根据业务进行配置，但无法进行扩展和定制 ","date":"2018-09-28","objectID":"/load-balance/:4:4","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"四、负载均衡典型架构 3 种常见的负载均衡机制：DNS 负载均衡、硬件负载均衡、软件负载均衡，每种方式都有一些优缺点，基于它们的优缺点进行组合使用。具体来说，组合的基本原则为：DNS 负载均衡用于实现地理级别的负载均衡；硬件负载均衡用于实现集群级别的负载均衡；软件负载均衡用于实现机器级别的负载均衡。 如下图所示。 整个系统的负载均衡分为三层。 地理级别负载均衡：www.xxx.com 部署在北京、广州、上海三个机房，当用户访问时，DNS 会根据用户的地理位置来决定返回哪个机房的 IP，图中返回了广州机房的 IP 地址，这样用户就访问到广州机房了。 集群级别负载均衡：广州机房的负载均衡用的是 F5 设备，F5 收到用户请求后，进行集群级别的负载均衡，将用户请求发给 3 个本地集群中的一个，我们假设 F5 将用户请求发给了“广州集群 2”。 机器级别的负载均衡：广州集群 2 的负载均衡用的是 Nginx，Nginx 收到用户请求后，将用户请求发送给集群里面的某台服务器，服务器处理用户的业务请求并返回业务响应。 需要注意的是，上图只是一个示例，一般在大型业务场景下才会这样用，如果业务量没这么大，则没有必要严格照搬这套架构。例如，一个大学的论坛，完全可以不需要 DNS 负载均衡，也不需要 F5 设备，只需要用 Nginx 作为一个简单的负载均衡就足够了 ","date":"2018-09-28","objectID":"/load-balance/:5:0","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"五、负载均衡算法 ","date":"2018-09-28","objectID":"/load-balance/:6:0","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"1、轮询 负载均衡系统收到请求后，按照顺序轮流分配到服务器上。轮询是最简单的一个策略，无须关注服务器本身的状态，适合服务器硬件同相同的场景。 集群中配置不一样，负载均衡系统也是不关注的，有新的机器是 32 核的，老的机器是 16 核的，新老机器分配的任务数是一样的。 需要注意的是负载均衡系统无须关注“服务器本身状态”，这里的关键词是“本身”。也就是说，只要服务器在运行，运行状态是不关注的。但如果服务器直接宕机了，或者服务器和负载均衡系统断连了，这时负载均衡系统是能够感知的，也需要做出相应的处理。例如，将服务器从可分配服务器列表中删除，否则就会出现服务器都宕机了，任务还不断地分配给它，这明显是不合理的。 优点： 简单 缺点： 服务器压力不一样，不适合服务器配置不同的情况； ","date":"2018-09-28","objectID":"/load-balance/:6:1","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"2、加权轮询 负载均衡系统根据服务器权重进行任务分配，这里的权重一般是根据硬件配置进行静态配置的，采用动态的方式计算会更加契合业务，但复杂度也会更高。 加权轮询是轮询的一种特殊形式，其主要目的就是为了解决不同服务器处理能力有差异的问题。例如，集群中有新的机器是 32 核的，老的机器是 16 核的，那么理论上我们可以假设新机器的处理能力是老机器的 2 倍，负载均衡系统就可以按照 2:1 的比例分配更多的任务给新机器，从而充分利用新机器的性能。 优点： 根据权重，调节转发服务器的请求数目，解决了轮询算法中无法根据服务器的配置差异进行任务分配的问题 缺点： 使用相对复杂 还是无法根据服务器的状态差异进行任务分配的问题。 ","date":"2018-09-28","objectID":"/load-balance/:6:2","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"3、负载最低优先 负载均衡系统将任务分配给当前负载最低的服务器，这里的负载根据不同的任务类型和业务场景，可以用不同的指标来衡量。例如： LVS 这种 4 层网络负载均衡设备，可以以“连接数”来判断服务器的状态，服务器连接数越大，表明服务器压力越大 Nginx 这种 7 层网络负载系统，可以以“HTTP 请求数”来判断服务器状态（Nginx 内置的负载均衡算法不支持这种方式，需要进行扩展）。 如果我们自己开发负载均衡系统，可以根据业务特点来选择指标衡量系统压力。如果是 CPU 密集型，可以以“CPU 负载”来衡量系统压力；如果是 I/O 密集型，可以以“I/O 负载”来衡量系统压力。 负载最低优先的算法解决了轮询算法中无法感知服务器状态的问题，由此带来的代价是复杂度要增加很多。例如： 最少连接数优先的算法要求负载均衡系统统计每个服务器当前建立的连接，其应用场景仅限于负载均衡接收的任何连接请求都会转发给服务器进行处理，否则如果负载均衡系统和服务器之间是固定的连接池方式，就不适合采取这种算法。例如，LVS 可以采取这种算法进行负载均衡，而一个通过连接池的方式连接 MySQL 集群的负载均衡系统就不适合采取这种算法进行负载均衡。 CPU 负载最低优先的算法要求负载均衡系统以某种方式收集每个服务器的 CPU 负载，而且要确定是以 1 分钟的负载为标准，还是以 15 分钟的负载为标准，不存在 1 分钟肯定比 15 分钟要好或者差。不同业务最优的时间间隔是不一样的，时间间隔太短容易造成频繁波动，时间间隔太长又可能造成峰值来临时响应缓慢。 负载最低优先算法基本上能够比较完美地解决轮询算法的缺点，因为采用这种算法后，负载均衡系统需要感知服务器当前的运行状态。当然，其代价是复杂度大幅上升。通俗来讲，轮询可能是 5 行代码就能实现的算法，而负载最低优先算法可能要 1000 行才能实现，甚至需要负载均衡系统和服务器都要开发代码。负载最低优先算法如果本身没有设计好，或者不适合业务的运行特点，算法本身就可能成为性能的瓶颈，或者引发很多莫名其妙的问题。所以负载最低优先算法虽然效果看起来很美好，但实际上真正应用的场景反而没有轮询（包括加权轮询）那么多。 ","date":"2018-09-28","objectID":"/load-balance/:6:3","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"4、Hash 类 负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上，这样做的目的主要是为了满足特定的业务需求。常见的有源地址 Hash、目标地址 Hash、session ID hash 、用户id hash，例如： 1、源地址 Hash 将来源于同一个源 IP 地址的任务分配给同一个服务器进行处理，适合于存在事务、会话的业务。例如，当我们通过浏览器登录网上银行时，会生成一个会话信息，这个会话是临时的，关闭浏览器后就失效。网上银行后台无须持久化会话信息，只需要在某台服务器上临时保存这个会话就可以了，但需要保证用户在会话存在期间，每次都能访问到同一个服务器，这种业务场景就可以用源地址 Hash 来实现。 2、ID Hash 将某个 ID 标识的业务分配到同一个服务器中进行处理，这里的 ID 一般是临时性数据的 ID（如 session id）。例如，上述的网上银行登录的例子，用 session id hash 同样可以实现同一个会话期间，用户每次都是访问到同一台服务器的目的。 ","date":"2018-09-28","objectID":"/load-balance/:6:4","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["分布式"],"content":"参考资料 大型网站架构系列：负载均衡详解 负载均衡 MGW——美团点评高性能四层负载均衡 极客时间：从0开始学架构 载均衡总结（四层负载与七层负载的区别) ","date":"2018-09-28","objectID":"/load-balance/:7:0","tags":["负载均衡"],"title":"负载均衡的那些事","uri":"/load-balance/"},{"categories":["经验总结"],"content":"今天在公司遇到一个奇怪的问题，耗费了大半天才解决。特此总结记录一下解决思路与方法，以便后续能为更快定位类似的问题。 ","date":"2018-08-06","objectID":"/how-to-solve-connection-refused-errors-in-ssh-connection/:0:0","tags":["idea"],"title":"linux可以ping通但是无法ssh登陆的问题","uri":"/how-to-solve-connection-refused-errors-in-ssh-connection/"},{"categories":["经验总结"],"content":"问题现象： 无法登陆公司小网中的一台虚拟机，该虚拟机有两张网卡，分别配有两个网段的IP。其中一个网段的IP可以ping通，但是无法ssh登陆，显示ssh: connect to host 192.171.25.101 port 22: Connection refused，另外一个网段的IP可以ssh登陆。 ","date":"2018-08-06","objectID":"/how-to-solve-connection-refused-errors-in-ssh-connection/:0:1","tags":["idea"],"title":"linux可以ping通但是无法ssh登陆的问题","uri":"/how-to-solve-connection-refused-errors-in-ssh-connection/"},{"categories":["经验总结"],"content":"问题定位过程： 刚开始定位思路是检查ssh服务是否ok？，检查是否打开防火墙？后来转念一想，这台虚拟机都可以通过另外一个网卡IP登陆，说明ssh服务是正常的。后来上网google一下遇到的现象，有篇英文文章提到可能是IP冲突导致ssh登陆不了。按照提示用arping命令检查一下有问题的IP是否冲突，果不其然，真的是冲突了。至此问题原因清楚了。IP冲突导致可以ping通该IP但是无法通过该IP ssh登陆虚拟机。 ","date":"2018-08-06","objectID":"/how-to-solve-connection-refused-errors-in-ssh-connection/:0:2","tags":["idea"],"title":"linux可以ping通但是无法ssh登陆的问题","uri":"/how-to-solve-connection-refused-errors-in-ssh-connection/"},{"categories":["经验总结"],"content":"问题解决办法： 一、检测linux下IP冲突的命令 arping：在IP冲突的同网段其他linux上执行arping命令检测是否有IP冲突。 [root@dev ~]# arping -I eth0 192.168.9.120 ARPING 192.168.1.120 from 192.168.9.200 eth0 Unicast reply from 192.168.9.120 [40:F4:EC:76:79:C2] 3.084ms Unicast reply from 192.168.9.120 [50:7B:9D:25:29:59] 0.817ms Unicast reply from 192.168.9.120 [50:7B:9D:25:29:59] 0.810ms 如果只检查出一个MAC地址，则表示网内A机器的的IP：192.168.9.120是唯一的 如果有以上信息即查出两个MAC地址，则表示网内有一台MAC地址为40:F4:EC:76:79:C2的主机IP地址与A机器相同。 这时可以通过ifconfig命令验证A机器，如下发现：A机器的MAC地址是50:7B:9D:25:29:59 。 我们可以用局域网扫描软件找到MAC地址为40:F4:EC:76:79:C2的主机，并将其隔离或更换IP地址。 检验原理： arping命令是以广播地址发送arp packets，以太网内所有的主机都会收到这个arp packets，但是本机收到之后不会Reply任何信息。 当我们在linux主机端上执行下面的命令时： arping 192.168.9.120　会默认使用eth0，向局域网内所有的主机发送一个： who has 192.168.9.120的arp request，tell 192.168.9.120 your mac address， 当这台windows主机端收到这个arp packets后，则会应答：“I am 192.168.9.120 , mac是00:25:e4:6a:4b:f4”，这样我们会收到mac地址为00:25:e4:6a:4b:f4的windows主机的Reply信息。 二、修改linux主机IP 修改冲突的IP地址，冲突的网卡是eth0， 修改/etc/sysconfig/network/ifcfg-eth0 的IP 重启网络 service sshd restart ","date":"2018-08-06","objectID":"/how-to-solve-connection-refused-errors-in-ssh-connection/:0:3","tags":["idea"],"title":"linux可以ping通但是无法ssh登陆的问题","uri":"/how-to-solve-connection-refused-errors-in-ssh-connection/"},{"categories":["经验总结"],"content":"问题引申： IP冲突除了出现上述能ping通但是ssh登陆不了的现象之外，还有可能出现一会儿能登陆、一会儿登陆不了，或者登陆的主机名偶尔会变。其原因可能是 IP地址冲突后，ssh 登录的设备并不是同一个设备，或者意外的不是你想要登录的设备，因此ssh登录时提示用户验证，但提示信息可能不一样（因为设备不一样了）。 ","date":"2018-08-06","objectID":"/how-to-solve-connection-refused-errors-in-ssh-connection/:0:4","tags":["idea"],"title":"linux可以ping通但是无法ssh登陆的问题","uri":"/how-to-solve-connection-refused-errors-in-ssh-connection/"},{"categories":["读书札记"],"content":"一直觉得物理是一门有趣的学科。大众对量子物理最熟悉的应该莫过于薛定谔的猫。当知道这世界还有一只猫在未被观测之前既是活着的又是死的，这个太违反常识了。根据人们以往的认知，猫要么是活的要么是死的，怎么可能又活着又死了呢？自此以后，对量子物理很好奇，觉得很神秘。 不知道在哪里看到的推荐，推荐这本科普量子物理的书–曹天元写的《上帝掷骰子吗？量子物理史话》。读这么书不要多么高深的物理知识，作者用通俗易懂的语言描述量子物理的历史，用讲故事的方式去描述那个在物理史上波澜壮阔、天才辈出的年代。天才们用自己的学识推到经典物理，重新构建新的物理大厦—量子物理和相对论。波尔、薛定谔、海森堡、爱因斯坦等大名如雷贯耳。本书对量子的起源以及相关科学家介绍、每种量子解释以及相关科学家介绍都恰到好处，而且对量子论的各种解释都有生动的比喻，也许不严谨，但十分适合我们这样的普通人理解。另外此书跨度也很大，从量子论的起源一直到介绍到超弦理论，基本把量子论的主要解释和相关科学家都介绍到了。对科学家的介绍主要都是一笔带过，有部分附带了趣闻，其他主要都把描述放在了对量子论各种解释的阐述上。 ","date":"2018-07-22","objectID":"/reading-notes-on-god-throws-the-dice-the-history-of-quantum-physics/:0:0","tags":["科技","物理"],"title":"读《上帝掷骰子吗？量子物理史话》","uri":"/reading-notes-on-god-throws-the-dice-the-history-of-quantum-physics/"},{"categories":["读书札记"],"content":"光的波粒二象性 关于光的本性，粒子和波动两种理论经历了300多年的争论，其中穿插着物理史上那些最伟大的名字：牛顿、胡克、惠更斯、麦克斯韦、赫兹、汤姆逊、爱因斯坦、德布罗意……。一方面双缝实验和麦克斯韦方程揭示光的波动性，另外一方面光电效应和康普顿效应又清晰表明光是粒子。后面波尔提出电子既是粒子也是波，波粒二象性。作为电子这个整体概念来说，它却表现出一种波-粒的二像性来，它可以展现出粒子的一面，也可以展现出波的一面，这完全取决于我们如何去观察它。讨论粒子还是波哪个是“真实”毫无意义。我们唯一能说的，是在某种观察方式确定的前提下，它呈现出什么样子来。 波和粒子在同一时刻是互斥的，但它们却在一个更高的层次上统一在一起，作为电子的两面被纳入一个整体概念中。这就是玻尔的“互补原理”（Complementary Principle），它连同波恩的概率解释，海森堡的不确定性，三者共同构成了量子论“哥本哈根解释”的核心，至今仍然深刻地影响我们对于整个宇宙的终极认识。 海森堡从不连续性出发创立矩阵力学，后面提出测不准定理，也叫做不确定性原理。不确定性原理说，不可能同时测准电子的动量p和位置q，任何精密的仪器也不行。观测本身会带来扰动，我们的结论和我们的观测行为本身大有联系。 波恩的概率解释，将骰子带进物理学，认为骰子才是薛定谔波函数ψ的解释，它代表一种随机，一种概率，薛定谔波函数ψ的平方代表了电子在某个地点出现的“概率”，出现的概率像一个波。 哥本哈根解释的基本内容，全都围绕着三大核心原理而展开： 首先，不确定性原理限制了我们对微观事物认识的极限，而这个极限也就是具有物理意义的一切。 其次，因为存在着观测者对于被观测物的不可避免的扰动，现在主体和客体世界必须被理解成一个不可分割的整体。没有一个孤立地存在于客观世界的“事物”（being），事实上一个纯粹的客观世界是没有的，任何事物都只有结合一个特定的观测手段，才谈得上具体意义。对象所表现出的形态，很大程度上取决于我们的观察方法。对同一个对象来说，这些表现形态可能是互相排斥的，但必须被同时用于这个对象的描述中，也就是互补原理。 最后，因为我们的观测给事物带来各种原则上不可预测的扰动，量子世界的本质是“随机性”。传统观念中的严格因果关系在量子世界是不存在的，必须以一种统计性的解释来取而代之，波函数ψ就是一种统计，它的平方代表了粒子在某处出现的概率。当我们说“电子出现在x处”时，我们并不知道这个事件的“原因”是什么，它是一个完全随机的过程，没有因果关系。 ","date":"2018-07-22","objectID":"/reading-notes-on-god-throws-the-dice-the-history-of-quantum-physics/:0:1","tags":["科技","物理"],"title":"读《上帝掷骰子吗？量子物理史话》","uri":"/reading-notes-on-god-throws-the-dice-the-history-of-quantum-physics/"},{"categories":["读书札记"],"content":"** 薛定谔的猫** 下面引用参考维基百科 薛定谔的猫：把一只猫、一个装有氰化氢气体的玻璃烧瓶和放射性物质放进封闭的盒子里。当盒子内的监控器侦测到衰变粒子时，就会打破烧瓶，杀死这只猫。在实验进行一段时间后，猫是死了还是活着？ 哥本哈根解释： 根据量子力学的哥本哈根诠释，在实验进行一段时间后，猫会处于又活又死的叠加态。可是，假若实验者观察盒子内部，他会观察到一只活猫或一只死猫，而不是同时处于活状态与死状态的猫。这事实引起一个谜题：到底量子叠加是在什么时候终止，并且坍缩成两种可能状态中的一种状态？ 当观察发生时，系统不再处于两种状态的叠加态，转而坍缩为其中任意一种状态。薛定谔的思想实验清楚地显露出一个事实，即在这种诠释里，测量或观察的概念并没有被良好定义。这思想实验可以被诠释为，当盒子仍旧是封闭的时候，系统同时存在于“衰变的原子／死猫”和“未衰变的原子／活猫”这两种状态的叠加态，只有当盒子被打开，进行观察时，波函数坍缩为其中任意一种状态。 多世界诠释： 1957年，休·艾弗雷特提出了量子力学的多世界诠释，它不把观察作为一个特殊的过程。按照多世界诠释，当盒子被打开后，猫的活状态和死状态都仍旧延续不断，但彼此之间发生了退相干。换句话说，当盒子被打开的时候，观察者和猫的纠缠态被割离为两个分支：观察者看着盒子里的死猫，和观察者看着盒子里的活猫。但是由于活和死的状态发生了退相干，它们之间不会出现有效的信息交流或相互作用。 根据多世界理论，每一个事件都是分支点。不论盒子是封闭的还是敞开的，猫是活的，也是死的，但是，活猫与死猫是处于宇宙的不同分支，这些分支都同样的真实，但是彼此之间不能相互作用。 客观坍缩理论: 根据客观坍缩理论（objective collapse theories），当某些客观的物理量达到其阈值（时间、质量、温度、不可逆性等）时，叠加态会自发地被摧毁。因此，早在盒子被打开之前，猫就已经如同预期地处在一个明确的状态。这可以被不严谨地说成“猫观察它自己”或“环境观察猫”。 客观坍缩理论要求对标准量子力学做出一些修改，使得叠加态可以被时间演化过程摧毁。 大家知道在猫实验里，如果原子衰变，猫就被毒死，反之则存活。对此，哥本哈根派的解释是：在我们没有观测它之前，猫是“又死又活”的，而观测后猫的波函数发生坍缩，猫要么死要么活。MWI则声称：每次实验必定同时产生一只活猫和一只死猫，只不过它们存在于两个平行的世界中。 两者有何实质不同呢？其关键就在于，哥本哈根派认为猫始终只有一只，它开始处在叠加态，坍缩后有50％的可能死，50％的可能活。而多宇宙认为猫并未叠加，而是“分裂”成了两只，一死一活，必定有一只活猫！ 薛定谔而落下的后遗症：从微观到宏观的转换。如果光子又是粒子又是波，那么猫为什么不是又死而又活着？如果电子同时又在这里又在那里，那么为什么桌子安稳地呆在它原来的地方，没有扩散到整间屋子中去？如果量子效应的基本属性是叠加，为什么日常世界中不存在这样的叠加，或者，我们为什么从未见过这种情况？ 我们已经听取了足够多耐心而不厌其烦的解释：猫的确又死又活，只不过在我们观测的时候“坍缩”了；有两只猫，它们在一个宇宙中活着，在另一个宇宙中死去；猫从未又死又活，它的死活由看不见的隐变量决定；单个猫的死活是无意义的事件，我们只能描述无穷只猫组成的“全集”……诸如此类的答案 购买链接 下面是书中的一些摘抄，其中的观点可以带来一些思考的启发。 美的东西往往是简约的 小孔成像说明了原来我们之所以能够看到物体，只是由于光从物体上反射到我们眼睛里的结果 对于一个科学理论来说，简洁优美要比实验数据的准确来得更为重要 物理学是什么？就是从实验观测出发，并以庞大负责的数学关系将他们联系起来的一门科学。 著名的悖论：一粒沙落地不算一个沙堆，两粒沙落地不算一个沙堆，但10万粒沙落地肯定是一个沙堆了。那么，具体到哪一粒沙落地时才形成一个沙堆呢？ 笛卡儿的“第一原理”：不管我怀疑什么也好，有一点我是不能怀疑的，那就是“我在怀疑”本身。 人择原理是说，我们存在这个事实本身，决定了宇宙的某些性质为什么是这样的而不是那样的。也就是说，我们讨论所有问题的前提是：事实上已经存在了一些像我们这样的智能生物来讨论这些问题。 哥本哈根学派认为不仅仅是猫，一切的一切，当我们不去观察的时候，都是处在不确定的叠加状态的，因为世间万物也都是由服从不确定性原理的原子组成。 波函数无需“坍缩”，去随机选择左还是右，事实上两种可能都发生了！只不过它表现为整个世界的叠加：生活在一个世界中的人们发现在他们那里电子通过了左边的狭缝，而在另一个世界中，人们观察到的电子则在右边！量子过程造成了“两个世界”！这就是量子论的“多世界解释”（Many Worlds Interpretation，简称MWI） 严格地说，历史和将来一切可能发生的事情，都已经实际上发生了，或者将要发生。只不过它们在另外一些宇宙里，和我们所在的这个没有任何物理接触。这些宇宙和我们的世界互相平行，没有联系，根据奥卡姆剃刀原理，这些奇妙的宇宙对我们都是没有意义的。多世界理论有时也称为“平行宇宙”（Parallel Universes）理论，就是因为这个道理 怎样表述一个命题才算是科学的？单靠有限的个例（哪怕再多）也不能构成证实的基础。 一个命题的逆否命题和它本身是等价的。 科学和形而上学的分界线画在“可证伪性”这里。也就是说，一个科学的论断必须是可能被证明错误的。比如我说：“世界上不存在白色的乌鸦。”这就是一个符合“科学方法”的论断，因为只要你真的找到一只白色的乌鸦，就可以证明我的错误，从而推翻我这个理论。但是，如前面我们举过的那个例子，假如我声称“我的车库里有一条看不见的飞龙。”，这就不是一个科学的论断，因为你无论如何也不能证明我是错的。 著名的热力学第二定律，它说，一个孤立体系的混乱程度总是不断增加的，它的量度称为“熵”。换句话说，熵总是在变大，时间的箭头指向熵变大的那个方向！ 霍金说了一句同样有名的话：“上帝不但掷骰子，他还把骰子掷到我们看不见的地方去！”这个看不见的地方就是黑洞奇点。 ","date":"2018-07-22","objectID":"/reading-notes-on-god-throws-the-dice-the-history-of-quantum-physics/:0:2","tags":["科技","物理"],"title":"读《上帝掷骰子吗？量子物理史话》","uri":"/reading-notes-on-god-throws-the-dice-the-history-of-quantum-physics/"},{"categories":["读书札记"],"content":"刻意练习针对每一个有梦想的人。它针对每个想学习怎样画画、编程、变戏法、吹萨克斯管、写出“伟大的小说”的人。它针对每个想提高自己的扑克牌技巧、垒球技能、销售技能、歌唱技艺的人。它针对所有那些想掌控自己的人生、塑造自己的潜力、不向命运低头、不甘心于现状的人。 ","date":"2018-04-17","objectID":"/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E5%A4%A7%E5%B8%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:0","tags":["自我管理"],"title":"《刻意练习：如何从新手到大师》读书笔记","uri":"/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E5%A4%A7%E5%B8%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["读书札记"],"content":"刻意练习是什么 总结一句话是：**刻意练习是一种能获得指导的有目的练习，而且知道该朝什么方向发展，以及怎样去达到目标。 ** 1、有目的的练习特点 定义明确的具体目标，可以有效地用于引导你的练习 有目的的练习是专注的 有目的的练习包含反馈 有目的的练习需要走出舒适区 总结有目的的练习：走出你的舒适区，但要以专注的方式制订明确的目标，为达到那些目标制订一个计划，并且想出监测你的进步的方法。还要想办法保持你的动机。 2、刻意练习的特点 刻意练习发展的技能，是其他人已经想出怎样提高的技能，也是已经拥有一整套行之有效的训练方法的技能 刻意练习发生在舒适区之外，要求不断地尝试那些刚好超出他当前能力范围的事物，需要人们付出最大限度的努力。 刻意练习包含得到良好定义的特定目标，通常还包括目标表现的某些方面；它并非指向某些模糊的总体改进 刻意练习是有意而为的，也就是说，它需要人们完全的关注和有意识的行动 刻意练习包含反馈，以及为应对那些反馈而进行调整的努力。 ","date":"2018-04-17","objectID":"/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E5%A4%A7%E5%B8%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:1:0","tags":["自我管理"],"title":"《刻意练习：如何从新手到大师》读书笔记","uri":"/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E5%A4%A7%E5%B8%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["读书札记"],"content":"如何运用刻意练习原则 在实践中，这往往归结为带有几个额外步骤的有目的的练习： 首先辨别杰出人物 然后推测是什么使他们变得如此杰出 接着再提出训练方法，这些方法使你也能像他们那样表现卓越 在自己的工作，仔细思考杰出的表现具有哪些特点，并尝试采用一些方法来度量，即使在你度量时一定存在着某种程度的主观意识也无妨。然后，寻找你所在行业或领域中评分最高、你认为对杰出表现十分关键的人。要记住，理想的情况是找到客观的、可复制的测量指标，以便前后一致地从普通从业者之中挑选出最优异的从业者。 运用刻意练习原则的人都面临一个重大挑战，那便是：要准确地判断最杰出人物做了些什么，使得他们在普通人中间“鹤立鸡群”。 在IT互联网行业，牛人很多。大多数牛人都有着做出牛逼产品的经历，比如微信之父张小龙、小米创始人雷军。是什么促使他们做出牛逼的产品？到底是什么是他们变得如此杰出？这几个问题其实是不好找到客观的、可复制的测量指标。 1、如何在工作中运用刻意练习原则 把自己逼出舒适区，即使反馈练习的效果，以促进正循环 边干边学，以练习为导向，想尽各种办法在日常的工作和生活中磨砺自己的技能 王牌飞行员训练方法最重要的是强调动手做，这里的底线是你能做什么，而不是你知道什么 拒绝三种错误的思想： 认为某人的能力是受基因的限制，将“我不能”挂在嘴边 错误的以为只要足够长时间做某事，就一定会更擅长。（以完全相同的方式一而再再而三地做某件事情，并不是提高绩效和表现的秘诀；它会使人们停下前进的脚步，并且缓慢地下滑。一年的工作经验重复三年是不能称之为有三年工作经验的） 错误的认为，要想提高，只需要努力即可。（需要正确的有目的的练习才能提高） 2、如何在生活中运用刻意练习原则 适合刚刚开始进行刻意练习的任何人：专注和投入至关重要，因此，制订明确的目标，把练习课程的时间缩得更短，是更加迅速地提升新的技能水平的最佳方式。在较短的时间内投入百分之百的努力来练习，比起在更长时间内只投入70%的努力来练习，效果更好 为了在没有导师的时候有效地练习某种技能，牢牢记住以下三个F，将是有帮助的。这三个F，其实是以字母F开头三个单词，即：专注（focus）、反馈（feedback）以及纠正（fix it）。将技能分解成一些组成部分，以便反复地练习，并且有效地分析、确定你的不足之处，然后想出各种办法来解决它们。 应当每天花固定的1个小时或更多的时间，专心练习那些需要全神贯注投入才能做好的事情。 精心设置目标，以便你能持续不断地看到进步的实质性信号，尽管并不会总是出现重大的进步。将漫长的旅程分解成一系列可控的目标，并且每次只关注它们中的一个，甚至可以在每次达到一个目标时，给自己小小的奖励。 当你自己水平技能改变了时，可能需要更换导师。 要记住：如果你在走神，或者你很放松，并且只为了好玩，你可能不会进步 杰出人物往往做两件有益的事情，它们看起来似乎都与动机无关。 身体保养：保证充足的睡眠并保持健康。如果你疲倦了或者生病了，就更难保持专注，更易分心走神。小提琴学生全都注意让自己每天晚上保持高质量的睡眠，他们中的很多人还会在上午的练习结束之后午休一会儿。 将练习课的时间限制在1小时左右。如果比那个时间长得多，你将无法保持高度的专注。而且，你刚开始练习的时候，可能还要将时间压缩一些。如果你的练习时间超过1小时，过1小时就休息一下。 ","date":"2018-04-17","objectID":"/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E5%A4%A7%E5%B8%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:2:0","tags":["自我管理"],"title":"《刻意练习：如何从新手到大师》读书笔记","uri":"/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BB%8E%E6%96%B0%E6%89%8B%E5%88%B0%E5%A4%A7%E5%B8%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["经验总结"],"content":"最近利用gitpage+hexo搭建好自己的博客后，想将自己的之前的csdn博客批量迁移到自己新的hexo博客上，网上搜索了一下， 发现有人已经用python写了个工具，可以将博客导出为Markdown和HTML格式：csdn-blog-export 。 用法也很简单：./main.py -u 你的CSDN用户名 -f markdown 或者 ./main.py -u cecesjtu -f html 然而脚本直接download下来发现不行，打开源码debug一下。将自己的**（博客主题需切回旧的主题“编程工作室”，我的“大白”主题失效）** ，修改部分源码：修复获取博客页数的bug、去除正文中博文标题。 终于拿到自己在csdn上的博客。但是此时导出的博文还不满足hexo博客的格式，于是用python写了个工具转换成满足hexo格式的.md文件。 title: 批量导出CSDN博客至hexo的解决办法 date: 2018-03-31 23:34:06 tags: [hexo,csdn博客,博客迁移] categories: [\"经验总结\"] 用法： 利用导出脚本同时导出.md格式和.html格式 利用转换脚本 转换导出的csdn博客为hexo格式的博客 特性：Python脚本从.html文件中提取出博文标题、博文创建时间、标签、分类，将它们插入对应的.md文件 转换后最终结果： title: 读《王二的经济学故事》 date: 2018-01-18 23:25:44 tags: [经济学, 理财] category: 读书札记 前段时间看到一个微信公众号推荐一本通俗的经济读物《王二的经济学故事》，在亚马逊试读来一下，觉得很有趣，便从亚马逊下单买了kindle电子版。 作者用生活中通俗易懂的故事来解释经济学，主要通过主人公王二来阐述解释中国主要的经济政策和经济活动。该书读起来一点也不晦涩难懂，十分有趣，读完后对中国一些常见的经济现象有一定的思考启发。 搞定：）代码已上传到github上，入口：https://github.com/Jordanzheng/csdn-blog-export ","date":"2018-03-31","objectID":"/how-to-export-your-csdn-blog/:0:0","tags":["hexo","csdn博客","博客迁移"],"title":"批量导出CSDN博客至hexo的解决办法","uri":"/how-to-export-your-csdn-blog/"},{"categories":null,"content":"前段时间看到一个微信公众号推荐一本通俗的经济读物《王二的经济学故事》，在亚马逊试读来一下，觉得很有趣，便从亚马逊下单买了kindle电子版。 作者用生活中通俗易懂的故事来解释经济学，主要通过主人公王二来阐述解释中国主要的经济政策和经济活动。该书读起来一点也不晦涩难懂，十分有趣，读完后对中国一些常见的经济现象有一定的思考启发。 下面引用亚马逊的推荐语 王二是谁？是你，是我，是他。王二的经济学故事，就是我们每个人的故事。看哈佛经济学博士郭凯如何用故事讲透我们生活中的经济学。 郭凯是新生代经济学者中最优秀、最受瞩目和喜爱的一位。他有着极好的经济学功底，先后获北京大学经济学硕士和哈佛大学经济学博士。难能可贵的是，他长于把深厚的经济学功底、严密的逻辑和幽默轻松的讲述方式完美地结合在一起，《王二的经济学故事》就是一个好的诠释。 《王二的经济学故事》用生动有趣的寓言故事来说明经济学的本质，非常通俗易懂，即使没有经济学基础的读者也能读懂。而对于有经济学功底，甚至是专业圈内的人来说，会提供另外一种看待经济学的独特视角。 《王二的经济学故事》有趣、清晰、幽默、深刻、理性、温和，对于大众读者和经济学界来说，都是一本不可多得的高品质的经济学通俗读物。 [ 购买链接 ](https://www.amazon.cn/dp/B075N2WFLF/ref=sr_1_1?s=digital- text\u0026ie=UTF8\u0026qid=1516122545\u0026sr=1-1\u0026keywords=%E7%8E%8B%E4%BA%8C%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%95%85%E4%BA%8B) 下面是书中的一些摘抄，其中的观点可以带来一些思考的启发。 《王二的经济学故事》 作者：郭凯 我们的不少收入分配差距不是因为市场经济的结果，而恰恰是因为我们还不够市场经济。 春运票价的辩论不只是一个价格问题的辩论，更是一个分配问题的辩论。 房价也有着类似的特征——不仅仅是价格问题 导致房价高的原因有很多，但其中的一个原因就是不少人购房不是用来居住的，而是用来投资的。 中国市场环境的问题之一就是宏观价格扭曲。一个例子就是利率偏低，其结果是老百姓补贴银行和企业。 还有一个例子就是汇率偏低，其结果是中国人补贴外国人和出口商，而惩罚国内消费者。 中国市场环境的另一个问题就是政府仍然过于强大。 价格的扭曲和垄断经营造成资源不能得到有效配置， 我们是不可能在一个不公平的基础上通过再分配得到一个公平社会的。 国企的利润应该给全国人民提供福利，而不是只给国企自己提供福利。 收入分配和财富分配是两个截然不同的概念。收入分配是针对收入这样一个流量概念而言的。收入，通常指的是一个人在给定的时间里能挣多少钱，这里面包含工资、红利和其他各种现金流入。财富分配则是针对财富这样一个存量概念而言的。财富，通常指的是一个人在某个时点有多少财产，这里面包含现金、股票、房产和其他各种资产。通常，收入高的人财富可能也多，但这不是必然的，一个挥金如土的投资银行家可能有很高的收入却没有什么财富；同样，一个守财但无所事事的富家子弟，可以有很多的财富但却没有收入。 当我们讨论收入和财富分配不均的时候，更要关注的是消灭不合理、不合法的分配不均，而不是分配不均本身。 讨论税负高不高，一个很关键的变量是政府通过收税所提供的服务和公共产品的质量及数量如何。 解决公共部门效率低的最有效办法，未必是提高公共部门的效率（虽然这是应该做的），而是缩小公共部门的规模，让市场和私人部门来提供那些不是非公共部门提供不可的产品和服务。 究竟应该不应该对实物福利，或者说非货币福利征个人收入所得税？这里的答案是：应该征。 改变土地财政的现状意味着需要重新审视整个中国的财政体系以及中央和地方的财政分权关系。把目标设成增长不超过0％ 土地收入是地方政府重要的收入来源，改变土地财政的现状意味着需要重新审视整个中国的财政体系以及中央和地方的财政分权关系。 中国的低息政策和缺乏好的投资渠道，是使得房产成为如此具有吸引力的投资品的巨大原因。 为什么户口还有好户口和差户口之分？因为户口背后的东西是机会的不均等、福利的不均等和环境的不均等。户口本身就是一个特供证。 房地产也许是中国人保存财富最不差的手段之一。 当一个经济中最好的投资方式竟然是买房的时候，这也恰恰说明了这个经济的金融体系可能存在缺陷。 如何把一种稀缺的资源——粮食，分配给周围的人。不管他怎么做，粮食是稀缺的这件事情都无法改变。 中国外汇储备问题，归根结底，是中国不平衡的经济结构的结果，是中国收入分配、资源配置和产业结构不平衡的体现。 一日人民币不可自由兑换，一日人民币就不可能成为一个真正的国际货币。 蒙代尔不可能三角说的是独立的货币政策、资本的自由流动和固定汇率，三者不可能同时实现。 著名的“一价定律”——同样的东西，在刨除运输和其他成本之后，在不同地方的价格应该不会总是存在很大差距。 数量宽松面对的现实难题是：美联储并不知道该印多少票子才合适，同时并不能保证印的票子不大量流向国外。 加工贸易是中国对外贸易顺差的主要原因。从中美双边经贸来看，加工贸易也是对美造成顺差的大头，占了70%到80%。 重商主义者的错误在于把贸易看成了一个零和博弈，有人赚钱就必然有人亏钱。 中国自己的钱为什么最终沦落到了必须要投在海外，而视国内的大好投资机会而不见？这个问题的答案最终恐怕要归咎于中国金融体系自身的问题。如果中国的金融体系没法有效地把中国自己的资金投向最需要钱的地方，从而获得最高的回报，我们没有理由抱怨外国人能够发现更好的投资机会。外资能比中资更赚钱，提醒我们的是我们的金融体系还非常缺乏效率。 正版的高价不是盗版的原因，其实是盗版的结果。 ","date":"2018-01-18","objectID":"/%E8%AF%BB%E7%8E%8B%E4%BA%8C%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%95%85%E4%BA%8B/:0:0","tags":["经济学","理财"],"title":"读《王二的经济学故事》","uri":"/%E8%AF%BB%E7%8E%8B%E4%BA%8C%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%95%85%E4%BA%8B/"},{"categories":null,"content":"身体是革命的本钱，作为程序员，没有一个好的身体，是写不长久代码的。同时，程序员也是个高危行业，经常熬夜加班，有着各种职业病：如颈椎病、腰椎病、手腕综合症、近视。所以锻练对于程序员来说是十分必要的。但是IT这一行时间由十分宝贵，** 如何有效的锻练身体，保持一个好的身体状态，对于程序员来说至关重要。 ** BBC纪录片**《锻炼的真相》**拍摄探讨关于锻练对身体有哪些影响、以及对如何锻练给出一些建议。总结一句话就是： ** 抬起屁股，不断活动，再结合一周三分钟的高强度HIT训练 ** 1.锻炼前做热身准备活动 2.做HIT运动（高强度运动） 3.多动起来，能走着就别站着，能站着就别坐着 4.坐的时间最好不要超过一小时，久坐不动绝对是健康杀手 下面是纪录片提到的一些观点： 脂肪分为皮下脂肪和内脏脂肪，皮下脂肪如腰部脂肪，并没有危害，反而能够祈祷保护作用；而内脏脂，才是我们真正需要减掉的地方，内脏脂肪存在如胃里、肝脏、胰腺周围等，不能出现“外瘦内胖”的损害健康的现象 不应该让坐着的时间超过一小时，因为身体闲下来时，黏性物质不断累积，造成血糖和血脂上升；久坐不动是健康杀手 平时跑步大约消耗16卡路里每分钟 饭前最好能够走走路(90分钟，太长)，这样，饭后，血液中的脂肪(1.66)与饭前没有走路(2.44)的相比，能降三分之一 经常走路锻炼，可以激活产生一种脂蛋白脂肪酶，这种酶能够降低血糖含量 研究提出“HIT”理论，即每周三次，每次三组，每组20秒的时间共计 3分钟/周 进行短时间内高强度训练能够达到每周花费2~3小时泡在健身房的效果，”HIT“一是提高胰岛素的敏感性，二是有氧适能，增加有氧代谢。注意，并不是所有人都会有效果，即所谓的“不应答”者。这种理论的依据是建立在：葡萄糖是以糖原的形式存储在肌肉内，糖原是肌肉与血液之间交互的关键信号，通过短时间的高强度运动可以分解肌肉内糖原，从而促进肌肉吸收血液中的糖原使血液中的糖原含量降低。平时我们散步或慢跑运动，身体只有约20%~30%的肌肉组织参与了运动，而短时间的高强运动能够激活高达70%~80%的肌肉组织同步锻炼。 NEAT：非运动性热量消耗（日常活动消耗能量），强调的是，平时尽量多活动，能坐就别躺，能站就别坐，能走就别呆着 每个人从同量的运动中获得的益处相差巨大，一项持续四年，1000人的样本每周锻炼4个小时，跟踪20周的调查发现，有15%的人锻炼效果明显，这类人属于超级反应者，而令人震惊的是有20%的人变化不大，既有这样的巨大反差，这与人体自身的11个 基因有关 ","date":"2017-12-18","objectID":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E5%A5%BD%E7%9A%84%E8%BA%AB%E4%BD%93%E7%8A%B6%E6%80%81/:0:0","tags":["程序员"],"title":"程序员如何保持好的身体状态","uri":"/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E5%A5%BD%E7%9A%84%E8%BA%AB%E4%BD%93%E7%8A%B6%E6%80%81/"},{"categories":null,"content":"今天在写shell 脚本时，需要几条命令串起来执行，并且前面命令执行失败了，后面命令就不行了。上网google一下，找到解决办法，采用逻辑与 ** \u0026\u0026 ** 即可。 下面总结一下shell执行多命令的方法。 一、分号；分割 command1;command2;command3;... 前面命令失败了不影响后面的命令执行。 二、逻辑与 \u0026\u0026 ** 命令执行返回值为0表明执行成功 ** command1 \u0026\u0026 command2 \u0026\u0026 command3 \u0026\u0026 ... 命令都用\u0026\u0026串接，从左到右执行，当前面的命令执行“成功”后才继续执行后面的命令。 另外，在script文件中，如果某一行太长写不完，command1 太长，可以在行末，放置接续上行的符号”\\”。 command1 \u0026\u0026 \\ command2 \u0026\u0026 \\ command3 \u0026\u0026 ... 三、逻辑或 || command1 || command2 || command3 || ... 从左到右执行，当前面的命令执行“失败”后才继续执行后面的命令。若前一个命令执行成功，就不会执行下一条了。 ","date":"2017-12-07","objectID":"/multiple-commands-for-linux-shell/:0:0","tags":["shell"],"title":"Multiple commands for Linux shell","uri":"/multiple-commands-for-linux-shell/"},{"categories":null,"content":"转自zenany的 About Time and Knowledge Management 关于时间管理和[“知识管理”]这两个话题，我见过最好的一个总结是： 此生理想、近期计划、今日功课 这是马英九的父亲马鹤凌为马英九制定的人生规划解决之道，是从我的师傅 nwind 的一场培训 [ 工程师的个人发展规划 ](https://speakerdeck.com/baidufe/gong-cheng-shi-de-ge-ren-fa-zhan- gui-hua) 中学到的。总结的很完美，但实践起来坑很多。分享一些我的实践经验，以及 Weekly 是怎么整理的。 此生理想 很多关于时间管理和[“知识管理”]的书最后都会指向这点： ** 你的理想是什么，你想成为什么样的人，你想要的生活是什么样的 ** 。因为只有搞清楚这点，时间和[“知识管理”]才是最高效的。拥有理想看起来很美好，然而现实是： ** 大多数人当下并没有真正想清楚自己的理想是什么 ** ，有可能是在年龄很大时才找到属于自己理想。有时候，我们貌似有了一个理想或梦想，但行动往往会出卖我们，暴露出真相并非如此。 所以，我的实践变成了： ** 不刻意去追寻理想，活在当下 ** 。做好这几件事： 专注于：解决问题+知识积累，这两件事可以保证知识和技能始总是提升的。不管最终理想是什么，知识和技能最后都会发挥作用。在解决问题的过程中，也会展现个人价值。 不要给自己设限，认定自己不能做什么，勇于尝试各种可能，逐步排除掉什么不是自己想要的。 近期计划 请注意：是“近期”而非“远期”，是“计划”而非“规划”。这一点，在理想的驱使下，很容易错误地被实践成长远规划。按我的经验：1 年内的计划比较容易可控，超过 1 年的变数太多，只能当做远景来确定方向。 我的实践是： ** 踏歌而行，踩着节拍往前走 ** 。保持节奏可以让我们的工作和学习有序前行，避免迷失方向。我通常这样做： - 按 年 -\u003e 月 -\u003e 周 这样的自然节奏进行，在上一个时间周期结束时确定下一个周期的事，比如：春节期间想好下一年的，每月初想好下月的事情，每周写周报或周末空闲时时想好下周要做的事，周末闲暇时间 \u0026 每天在路上想好每件事大致怎么做。所以在工作时，我往往只需执行。 - 不迷恋于各种日程及时间管理工具，用心记，当一周事情特别多时，用纸+笔 今日功课 关于这点，我想分享一个我总结出的词汇“可持续性编程”。为什么编程还需要可持续性，因为：一个人的工作生涯会在20 年以上，这是一场长跑。而且，从职业生涯的角度去看问题，会发现一些有意思的东西： - 很多当下的问题根本只是浪花一朵，比如：晋升、绩效、涨薪… - 很多看似不可能的东西变得可能，比如：掌握 N 种编程语言、研究清楚浏览器内核、学会一种乐器… 从编程生涯的角度来看，今日功课其实是每日功课，要跑好这场长跑，我觉得这几点很重要： 给自己一个 ** 安静的环境 ** ，同时省出学习时间 关掉聊天工具、消息提醒，QQ 我已经变成每 1 周甚至 1月去开一次了，在攻坚时我会不开邮件客户端、旺旺、钉钉 少刷微博、微信、新闻，甚至不看，需要时定期去扫即可，不用担心会漏掉什么，重要的东西总会通过各种渠道传递到你这里的 减少不必要的会议，每个技术交流都是一份非常好的学习机会，可以选择不去，但去了后就全心参与，不看手机、不开电脑，专心获取或输出有效信息 ** 健康的体魄 ** ，没有好身体，怎么写 20 年代码 工作必须有底线，也不能让自己长期处于高压工作下。我的习惯是：周末尽量不做实体性工作（除非计划有变）；平时不能牺牲吃饭+睡觉时间去赶进度。 适度运动，找到属于自己的一种方式。我会坚持每周去爬山一次，呼吸新鲜空气+思考问题 ** 持续学习的精神 ** ，这点 阮一峰老师 是我们的榜样。要保持持续学习，我觉得这两点非常重要： 兼容并蓄：不要给技术贴标签，以学习的心态去看待每个技术，了解它们思考和解决问题的方式、实现原理、应用场景，不断丰富自己对编程的认知和解决问题的思路。 格物致知：计算机科学是非常庞大的一门科学，足以支撑我们研究一辈子。前端所接触的，只是技术的冰山一角，还有很多东西需要我们去探索。格物致知能让我们掌握日常使用的技术背后的原理，从而提升掌控复杂的能力。 Weekly 是如何整理的 很多人会问我这个问题，其实，做这件事的初心很简单：记录自己平时看到的优质资料以备用，完善个人知识库。但由于常常有会把一些特别好的东西分享到群里，就有人建议我可以定期整理这类东西，发给大家。于是 Weekly 就开始了，坚持了好多年。 做这件事，我使用的 ** 工具 ** 是： RSS ：Feedly + gReader，离线、在线都能看，上网约等于看 rss 资源汇集地： hn-daily 、 JavaScript Weekly 等各种 weekly、技术组织官网、 Medium 、 JavaScriptKicks OneNote：记录感兴趣的文章和资源，比 evernote 快，稳定性、复制 html 的效率和效果、搜索等都更好用 微博：订阅一些喜欢分享资源的人或者组织，其实微博仍然是非常好的一个传播渠道 微信：订阅公众号 ** 方式： ** 定期看，而非实时关注，一般我会在周三晚上、周六集中扫一遍，筛选出有价值的和感兴趣的，周日汇总并完成整理 零散时间会看 rss 筛选信息，在周末或者晚上空闲时看自己感兴趣的文章 ** 信源： ** 雪球效应：以资源汇集点为起点，逐步收集优质资源来自的 bolg 、技术站点 整理自己感兴趣的知识，逐步形成个人知识库 总结 时间管理和[“知识管理”]可以围绕这 12 字去探索自己的模式：此生理想、近期计划、今日功课。 我的习惯和建议是： - 活在当下：专注于解决问题+知识积累；不给自己设限，去尝试未来的各种可能； - 踏歌而行，踩着节拍往前走：以 年 -\u003e 月 -\u003e 周 的维度制定计划；用心而非工具管理计划； - 可持续编程：安静的环境；健康的体魄；持续学习的精神； - [“知识管理”]：从信息汇聚源除非逐步形成自己的知识库；利用零散时间+定期扫的模式收集资源，在业余时间集中阅读 ","date":"2017-12-04","objectID":"/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%92%8C%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/:0:0","tags":["时间管理"],"title":"【转】关于时间和知识管理","uri":"/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%92%8C%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"},{"categories":null,"content":"该文引用自我的github文章，GitHub地址： https://github.com/Jordanzheng 下面是一些我读过的书。在此记录一下。 格式：（书名、作者(译者)、出版社、阅读完该书的时间），带超链接的是相关的读书笔记 ","date":"2017-11-28","objectID":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/:0:0","tags":["阅读"],"title":"已阅读书单","uri":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"索引 文学 小说 历史 经济管理 心理学 技术 杂类 ","date":"2017-11-28","objectID":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/:1:0","tags":["阅读"],"title":"已阅读书单","uri":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"文学 《平凡的世界》（普及本）by 路遥 北京十月文艺出版社。 2014年. 《当我谈跑步时，我谈些什么》 by [日] 村上春树 译者: 施小炜 南海出版公司。2014年. 《送你一颗子弹》by 刘瑜， 中信出版社。2016年. ","date":"2017-11-28","objectID":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/:2:0","tags":["阅读"],"title":"已阅读书单","uri":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"小说 《围城》by 钱钟书， 生活·读书·新知三联书店。 2013年 《兄弟》by 余华 ， 作家出版社。2013年 《活着》by 余华 ， 作家出版社。2013年 《明朝那些事儿》by 当年明月 ， 中国友谊出版公司 。2013年 《白鹿原》 by 陈忠实， 2014年 《陆犯焉识》 by 严歌苓 ， 作家出版社。 2014年 《恶意》by 东野奎吾，南海出版社。2017年 《解忧杂货店》by 东野奎吾，南海出版社。2017年 《嫌疑人x的现身》by 东野奎吾，南海出版社。2016年 《一只特立独行的猪》by 王小波，北京文学出版社。2016年 《黄金时代》by 王小波，北方文艺出版社。2017年 《白银时代》by 王小波，北方文艺出版社。2017年 《 王小波杂文集：沉默的大多》by 王小波，北方文艺出版社。2017年 《爱你就像爱生命》 by 王小波 李银河，北方文艺出版社。2017年 《三体I 地球往事》by 刘慈欣 ，重庆出版社。2016年 《三体II 黑暗森林》by 刘慈欣 ，重庆出版社。2016年 《三体III 死神永生》by 刘慈欣 ，重庆出版社。2016年 ","date":"2017-11-28","objectID":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/:3:0","tags":["阅读"],"title":"已阅读书单","uri":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"历史 《万历十五年》 by 黄仁宇 生活·读书·新知三联书店。 2013年 《中国大历史》 by 黄仁宇 生活·读书·新知三联书店。2013年 《现代中国的历程》 by 黄仁宇 生活·读书·新知三联书店 。 2014年 《邓小平时代》 by 傅高义 (作者),‎ 冯克利 (译者)，生活•读书•新知三联书店。2014年 《兴盛与危机:论中国社会超稳定结构》by 金观涛 (作者),‎ 刘青峰 (作者)，法律出版社。2014年 ","date":"2017-11-28","objectID":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/:4:0","tags":["阅读"],"title":"已阅读书单","uri":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"经济管理 《激荡三十年》by 吴晓波 ， 中信出版社。2014年 《经济学的思维方式（第11版） : 经济学导论》by [美] 保罗·海恩，马昕(译者), 世界图书出版公司。2014年 《富爸爸穷爸爸》 by (美）罗伯特.清崎，四川文艺出版社。2016年 《穷查理宝典：查理芒格智慧箴言录》by (查理.芒格)，上海人民出版社。 2016年 《牛奶可乐经济学》 by 罗伯特.弗兰克，2017年 ","date":"2017-11-28","objectID":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/:5:0","tags":["阅读"],"title":"已阅读书单","uri":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"心理学 《自控力》by 凯利•麦格尼格尔 (作者),‎ 王岑卉 (译者)，文化发展出版社。 2015年 《影响力：你为什么会说是》 by [美] 西奥迪尼 中国社会科学出版社。2015年 《高效能人士的七个习惯》by 史蒂芬·柯维 (作者),‎ 高新勇 (译者),‎ 王亦兵 (译者),‎ 中国青年出版社。 2016年 《如何把事情做到最好 》by 乔治·伦纳德 (作者),‎ 张乐 (译者)，中国青年出版社。2016年 《这才是心理学:看穿伪心理学的本质》by 基思·斯坦诺维奇 (作者),‎ 窦东徽 (译者)， 中国人民大学出版社。2017年 ","date":"2017-11-28","objectID":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/:6:0","tags":["阅读"],"title":"已阅读书单","uri":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"技术 《鸟哥的Linux私房菜.基础学习篇》（第三版）by 鸟哥 人民邮电出版社。2015年 《编码:隐匿在计算机软硬件背后的语言》 by Charles Petzold 译者：左飞，电子工业出版社。2016年 《Java编程思想(第4版)》 by 埃史尔 (作者),‎ 陈昊鹏 (译者) ，机械工业出版社。 2016年 《Java核心技术(卷1):基础知识》 by 霍斯特曼 (作者),‎ 科内尔(作者),‎ 周立新 (译者),‎ 机械工业出版社。 2016年 《Effective Java中文版(第2版)》 by Joshua Bloch (作者),‎ 杨春花 (译者),‎ 俞黎敏 (译者) ，‎ 机械工业出版社。 2016年 《程序员健康指南》 by Job Kutner ，人民邮电出版社。2017年 《程序员修炼之道:从小工到专家》by Andrew Hunt ／ David Thomas 译者：马维达， 电子工业出版社。2017年 《程序员的思维修炼:开发认知潜能的九堂课》 by Andy Hunt 译者：崔康，人民邮电出版社。2017年 《Head First设计模式(中文版)》 by 弗里曼， 中国电力出版社。2017年 《重构:改善既有代码的设计》 by Martin Fowler 译者：熊节， 人民邮电出版社。2017年 《黑客与画家》 by [美] 保罗·格雷厄姆 译者: 阮一峰 人民邮电出版社。2017年8月 《淘宝技术这十年 : 淘宝技术大学校长解密淘宝十年》by 子柳 ，电子工业出版社。 2017年10月 《软件开发者路线图：从学徒到高手》 by Hoover / Adewale Oshineye 机械工业出版社。2017年11月 ","date":"2017-11-28","objectID":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/:7:0","tags":["阅读"],"title":"已阅读书单","uri":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"杂类 《慢慢来，一切都来得及：心慢下来，行动才能快起来》by meiya 中国商业出版社。2014年 《暗时间》by 刘未鹏 电子工业出版社。2014年 《把时间当作朋友》by 李笑来， 2015年 《万万没想到:用理工科思维理解世界》by 万维钢(同人于野)， 电子工业出版社。 2016年 《番茄工作法图解:简单易行的时间管理方法》 by 诺特伯格 (作者),‎ 大胖 (译者)人民邮电出版社。 2016年 《如何阅读一本书》 by [美]莫提默·J·艾德勒 查尔斯·范多伦 (作者),‎ 郝明义 (译者)，商务印书馆，2016年 《顾中一说:我们到底应该怎么吃?》 by 顾中一 ，2016年 《MacTalk·人生元编程》by 池建强，2016年 《浪潮之巅》 by 吴军 电子工业出版社。2017年9月S ","date":"2017-11-28","objectID":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/:8:0","tags":["阅读"],"title":"已阅读书单","uri":"/%E5%B7%B2%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":" 经典书籍有助于提升自己，多读经典的编程书籍有利于夯实自己的基础。尽量抽空多读书吧。 带删除线的表示自己已经读过了。如 《软件开发者路线图：从学徒到高手》 在github看到一个编程相关的书单，列举编程相关的书籍。特此引用，原文github地址 [https://github.com/jobbole/awesome-programming-books](https://github.com/jobbole/awesome-programming- books) ，欢迎大家去star关注 100+ 经典技术书籍，涵盖：计算机系统与网络、系统架构、[“算法”]与数据结构、前端开发、后端开发、移动开发、数据库、测试、项目与团队、程序员职业修炼、求职面试 和 编程相关的经典书籍。 这个列表综合了伯乐在线网站以往推荐 经典书籍 文章中的列表，以及在微信和微博中被广泛推荐的好书。虽然已经包括了100多本，覆盖的面也比较全。仍然有很多方面需要补充，而且相信还有很多没有被收录的好书。欢迎大家在 issues 中推荐或自荐。 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:0:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"计算机系统与网络 《 图灵的秘密:他的生平、思想及论文解读 》 《 计算机系统概论 》 《 深入理解Linux内核 》 《 深入Linux内核架构 》 《 TCP/IP详解 卷1：协议 》 《 Linux系统编程（第2版） 》 《 Linux内核设计与实现（第3版） 》 《 深入理解计算机系统（原书第2版） 》 《 计算机程序的构造和解释（原书第2版） 》 《 编码：隐匿在计算机软硬件背后的语言 》 《 性能之颠：洞悉系统、企业与云计算 》 《 UNIX网络编程 卷1：套接字联网API（第3版） 》 《 UNIX网络编程 卷2：进程间通信 》 《 Windows核心编程(第5版) 》 《 WireShark网络分析就这么简单 》 《 WireShark网络分析的艺术 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:1:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"编程通用 《 编程原本 》 《 代码大全 》 《 UNIX编程艺术 》 《 代码整洁之道 》 《 编程珠玑（第2版） 》 《 编程珠玑（续） 》 《 软件调试的艺术 》 《 修改代码的艺术 》 《 编程语言实现模式 》 《 编写可读代码的艺术 》 《解析极限编程：拥抱变化》 《 精通正则表达式（第3版） 》 《 编译原理（第2版） 》 《 重构：改善既有代码的设计 》 《 七周七语言：理解多种编程范型 》 《 调试九法：软硬件错误的排查之道 》 《程序设计语言：实践之路（第3版）》 《 计算的本质：深入剖析程序和计算机 》 《 设计模式 : 可复用面向对象软件的基础 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:2:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"[“算法”]与数据结构 《 [“算法”]（第4版） 》 《 [“算法”]导论（原书第2版） 》 《 Python[“算法”]教程 》 《 [“算法”]设计与分析基础（第3版） 》 《 学习 JavaScript 数据结构与[“算法”] 》 《 数据结构与[“算法”]分析 : C++描述（第4版） 》 《 数据结构与[“算法”]分析 : C语言描述（第2版） 》 《 数据结构与[“算法”]分析 : Java语言描述（第2版） 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:3:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"职业修炼与规划 《 大教堂与集市 》 《卓有成效的程序员》 《 程序员的职业素养 》 《 程序员修炼之道：从小工到专家 》 《 软件开发者路线图：从学徒到高手 》 《 我编程，我快乐: 程序员职业规划之道 》 《 程序员的思维修炼：开发认知潜能的九堂课 》 《 高效程序员的45个习惯：敏捷开发修炼之道(修订版) 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:4:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"大师访谈 《 编程大师智慧 》 《 编程大师访谈录 》 《 编程人生 : 15位软件先驱访谈录 》 《 奇思妙想 : 15位计算机天才及其重大发现 》 《 图灵和ACM图灵奖 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:5:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"架构/性能 《 微服务设计 》 《 大数据日知录 》 《 企业应用架构模式 》 《 Web性能权威指南 》 《 SRE：Google运维解密 》 《 发布！软件的设计与部署 》 《 高扩展性网站的 50 条原则 》 《 大型网站技术架构:核心原理与案例分析 》 《 恰如其分的软件架构：风险驱动的设计方法 》 《 软件系统架构：使用视点和视角与利益相关者合作（第2版） 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:6:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"Web前端 《 高性能 JavaScript 》 《 锋利的 jQuery（第2版） 》 《 JavaScript 忍者秘籍 》（感谢 @joker-danta 补充推荐） 《 编写可维护的 JavaScript 》 《 你不知道的 JavaScript（上） 》 《 JavaScript 权威指南（第6版） 》 《 JavaScript 语言精粹（修订版） 》 《 JavaScript DOM编程艺术 （第2版） 》 《 JavaScript 高级程序设计（第3版） 》 《 JavaScript 异步编程：设计快速响应的网络应用 》 《 Effective JavaScript：编写高质量JavaScript代码的68个有效方法 》 《 HTML5 权威指南 》 《 HTML5 秘籍（第2版） 》 《 HTML5 与 CSS3 基础教程（第八版） 》 《 CSS 揭秘 》 《 CSS 设计指南（第3版） 》 《 CSS 权威指南（第3版） 》 《 深入浅出 HTML 与 CSS 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:7:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"Java开发 《 Java8 实战 》 《 Java并发编程实战 》 《 Java性能权威指南 》 ~~ 《 Java程序员修炼之道 》~~ 《 实战Java高并发程序设计 》 《 Java编程思想 （第4版） 》 《 深入理解Java虚拟机（第2版） 》 《 Effective java 中文版（第2版） 》 《 Java核心技术·卷1：基础知识（原书第9版） 》 《 Java核心技术·卷2：高级特性（原书第9版） 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:8:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":".NET 《 精通C#（第6版） 》 《 深入理解C#（第3版） 》 《 CLR via C#（第4版） 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:9:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"Python 《 集体智慧编程 》 《 笨办法学Python 》 《 Python基础教程 》 《Python源码剖析》 《 Head First Python 》 《 与孩子一起学编程 》 《 Python学习手册（第4版） 》 《 Python Cookbook（第3版） 》 《 Python参考手册（第4版） 》 《 Python核心编程（第3版） 》 《 Python科学计算（第2版） 》 《 利用 Python 进行数据分析 》 《 Think Python：像计算机科学家一样思考Python（第2版） 》 《 Python编程实战:运用设计模式、并发和程序库创建高质量程序 》 《 Python绝技：运用Python成为顶级黑客 》 《 Flask Web开发:基于Python的Web应用开发实战 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:10:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"Android 《 Android编程权威指南（第2版） 》 《 移动应用UI设计模式（第2版） 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:11:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"iOS 《 iOS编程实战 》 《 iOS编程（第4版） 》 《 Objective-C高级编程 》 《 Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:12:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"PHP 《 Head First PHP \u0026 MySQL（中文版） 》 《 深入PHP：面向对象、模式与实践（第3版） 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:13:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"C语言 《 C标准库 》 《 C和指针 》 《 C专家编程 》 《 C陷阱与缺陷 》 《 C语言接口与实现 》 《 C程序设计语言（第2版） 》 《C语言参考手册（第5版）》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:14:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"C++ 《 C++标准库 》 《 C++编程思想 》 《 C++语言的设计与演化 》 《 C++程序设计原理与实践 》 《 C++ Primer （中文第5版） 》 《 C++ Primer习题集(第5版) 》 《 C++程序设计语言(第1-3部分)(原书第4版) 》 《 Effective C++:改善程序与设计的55个具体做法(第3版)(中文版) 》 《 More Effective C++:35个改善编程与设计的有效方法(中文版) 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:15:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"机器学习和数据挖掘 《 数据之巅 》 《 矩阵分析 》 《 机器学习 》 《 统计学习方法 》 《 机器学习导论 》 《 推荐系统实践 》 《 机器学习实战 》 《 Web数据挖掘 》 《 深入浅出统计学 》 《 模式分类（第2版） 》 《 概率论与数理统计 》 《 统计学习基础(第2版)(英文) 》 《 数据挖掘：概念与技术（第3版） 》 《 数据挖掘：实用机器学习工具与技术（原书第3版） 》 《 大数据：互联网大规模数据挖掘与分布式处理（第2版） 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:16:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"数据库 《 SQL应用重构 》 《 SQL Cookbook 》 《 高性能MySQL （第3版） 》 《深入浅出SQL（中文版）》 《 MySQL技术内幕 : InnoDB存储引擎（第2版） 》 《 深入浅出MySQL : 数据库开发、优化与管理维护 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:17:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"测试 《 探索式软件测试 》 《 有效的单元测试 》 《 Google软件测试之道 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:18:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"项目与团队 《 人月神话 》 《 快速软件开发 》 《 人件（原书第3版） 》 《 门后的秘密：卓越管理的故事 》 《 极客与团队：软件工程师的团队生存秘笈 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:19:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"求职面试 《 程序员面试金典（第5版） 》 《 编程之美 : 微软技术面试心得 》 《 金领简历：敲开苹果、微软、谷歌的大门 》 《 剑指Offer：名企面试官精讲典型编程题（纪念版） 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:20:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"编程之外 《 暗时间 》 《 数学之美 》 《 赢得朋友 》 《 精益创业 》 《 批判性思维 》 《 世界是数字的 》 《 程序员的数学 》 《 程序员健康指南 》 《 禅与摩托车维修艺术 》 《 关键对话：如何高效能沟通 》 《 写作法宝：非虚构写作指南 》 《 黑客与画家 : 来自计算机时代的高见 》 《 软件随想录（卷1） 》《 软件随想录（卷2） 》 《 如何把事情做到最好：改变全球9800万人的人生指导书 》 ","date":"2017-11-23","objectID":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/:21:0","tags":["编程"],"title":"经典编程书籍书单","uri":"/%E7%BB%8F%E5%85%B8%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E4%B9%A6%E5%8D%95/"},{"categories":null,"content":"关于java的native关键字和JNI的概念解释，下面3篇参考文章写得已经很详细了，自己没必要再重复写一篇。在此记录，以便后续回顾。 参考文章： 1. java native方法及JNI实例 2. Java中的native关键字详解 3. Java的native关键字 ","date":"2017-11-07","objectID":"/java%E7%9A%84native%E6%96%B9%E6%B3%95%E5%92%8Cjni/:0:0","tags":["java"],"title":"java的native方法和JNI","uri":"/java%E7%9A%84native%E6%96%B9%E6%B3%95%E5%92%8Cjni/"},{"categories":null,"content":"该书并非一本关于如何设计软件的书，而是一本关于如何设计软件开发职业生涯的开端并为你在该领域创造成绩的书。该书是以模式语言的形式组织的。 ** 模式语言是针对特定领域中常见的问题的一组相互关联的解决方法。 ** 模式都包含一个“情景分析”、一个“问题描述”和一种“解决方法”，然后是一组单一或多重的行动。在每种模式接近尾声的地方都有一个“行动指南”的小节，这一小节描述了你可以立即付诸实践的具体事情。 任何模式都应包含给定情景中一大类问题的一揽子解决方案，记住这一点很重要。模式是用来修正以适应具体情形的，而不是用来生搬硬套的。 做软件学徒意味什么？ 1、必须学会自我成长，学会如何学习。对自身的关注和提高自身技能的要求。 2、空杯心态，已有的经验越多，你就越需要更多的努力进入到“空杯”状态，清除思想中的坏习惯，放下对技能水平的自鸣得意，敞开自己，从更有经验的同行那里学习不同的而且常常是违反直觉的新方法。 学徒期做什么赢得新团队的信任？ 主动完成简单无趣却又必须完成的任务。因为这表明你能完成高质量的工作。 这类任务包括维护构建系统，产品支持，响应维护需求，bug修正，代码复查，消除技术债务（technicaldebt），搭建项目wiki，更新文档，为其他人的想法充当传声筒，等等。通常，你会关注风险更低的系统边缘部分，而不是常常带有大量依赖性和极高复杂度的核心。 ","date":"2017-11-03","objectID":"/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%BA%BF%E5%9B%BE%E4%BB%8E%E5%AD%A6%E5%BE%92%E5%88%B0%E9%AB%98%E6%89%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:0","tags":["职业生涯"],"title":"《软件开发者路线图—从学徒到高手》读书笔记","uri":"/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%BA%BF%E5%9B%BE%E4%BB%8E%E5%AD%A6%E5%BE%92%E5%88%B0%E9%AB%98%E6%89%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"摘要 1、定期更新简历，定期面试。养成定期把自己的简历审查一遍的习惯。一边看一边把具体技能提取到一份单独的列表中。定期到去外面面试，看看自己处在什么位置，与市场需求由什么差距。看看自己的简历技能项还差什么。 2、写下跟工作有关，而且自己不甚了然的五件事。将这份列表放到自己经常可以看到的地方。然后随工作内容的改变养成不断更新这一列表的习惯。 3、要在编程方面真正擅长需要一生的努力，还有不断学习实践的进取心。 4、老板付你工钱是让你构建能为客户解决问题的东西。 5、做你自己喜爱的事，钱自然会来。 6、准备描述自己的职位头衔，确定它反映你实际的工作内容和技能水平。准备自己打算晋升职位的要求 7、学会那些本来不会做的事情，常常比去做已经会做的事情更加重要。 8、为[成为一名程序员]做准备，最好的方法就是写程序，并学习其他人写过的优秀程序。我当初所做的是：到计算机科学中心的垃圾筒中，去寻找他们操作系统的清单。 9、使用开源项目，阅读分析开源项目源码 10、在软件开发领域做一名会思考的从业者。这包括经常反思自己的工作状况。考虑一下自己的实践是新颖的，创新的，还是过时的。对那些团队中其他人都想当然的事情，多给自己画几个问号。 如果觉得目前工作中有些让人特别痛苦或开心的事情，问问自己事情是怎么变成这个样子的，如果问题是负面的，如何能改善它？我们的目标是通过将每一种经验拆分开，然后再以新的、有趣的方式组合起来，从其中提取最多数量的教育价值。 11、记录所学，不要低估写作的力量。写博客 12、分享所学，呈现自己出来，扩大自己影响力。 13、维护一张待阅读清单，用它来跟踪你打算读过的书，并记下已经读过的书。阅读清单里要包含经典名著和现代的、注重实效的图书 14、坚持阅读，即使每两个月读一本编程相关的书，每周也就35页，用不了多久，你就会对IT行业由深入的了解，并使自己不同于周围人。 15、拿出一本笔记簿，开始简单记录你对于本书的想法，或者它所激发的任何思想。所做的笔记一定要有个日期。读完这本书以后，针对所学的其他东西，继续按同样的方式使用这本本子。经过一段时 间，记下的条目就会成为博客、杂志文章，甚至一本书的基础。 16、Brooks法则，FredBrooks1975年在他的《The MythicalMan-Month》（人月神话）一书中提出：向进度落后的项目中增加人手，只会使进度更加落后。Brooks还打过另外一个有趣的比方：一个女人可以用九个月时间生产一名婴儿，但九个女人却不能用一个月时间生产一名婴儿。 17、深入了解挖掘一些工具、技术。知其然，更要知其所以然。 18、学习一个新概念，要去理解它的背景、历史上下文、它要解决的问题。这是个好习惯。 19、写下自己的常用工具列表，提升工作效率。定期考察是否有更好更强大的工具替代当前工具箱的工具。 本书附录，模式列表： 1.** 另辟蹊径（A DifferentRoad) ** : 你发现自己想要去的那个方向跟通往软件技能的道路并不相同。 2.** 只求最差（Be theWorst） ** : 当快速超越了周围的每一个人，你的学习速度下降了。 3.** 质脆玩具（BreakableToys） ** : 你工作在一个不允许失败的环境中，却需要一个安全的环境来学习。 4.** 具体技能（ConcreteSkills） ** : 你想到一个优秀的团队中工作，然而你掌握的实用技能很少。 5.** 正视无知（Confront YourIgnorance） ** : 你发现了自身知识中的许多漏洞，而你的工作需要你理解这些主题。 6.** 技重于艺（Craft overArt） ** :你需要向客户交付解决方案，你可以选择采用一种更简单且已证明有效的方案，也可以利用机会来创造一些新奇和美妙的东西。 7.** 建立馈路（Create FeedbackLoops） ** :你不知道自己是否正遭受“无意识的无能”（unconsciousincompetence）之苦。 8.** 深入挖掘（DigDeeper） ** : 你只拥有许多工具、技术和方法的肤浅认识，在尝试解决更困难问题的时候，不断地遇到障碍。 9.** 自定路线（Draw Your OwnMap） ** : 老板提供给你的职业道路全都不适合你。 10.** 提高带宽（Expand YourBandwidth） ** : 你对软件开发的理解较为狭隘，只关注日常工作中的低层次细节。 11.** 暴露无知（Expose YourIgnorance） ** : 你发现了自身知识中的许多漏洞，担心人们会认为你根本不明白自己所做的东西。 12.** 常用工具（FamiliarTools） ** : 你发现很难估算自己的工作，因为你的工具集和技术栈总是在快速变化。 13.** 找人指导（FindMentors） ** : 你发现自己花费大量的时间在发明轮子，然后不断遇到障碍，但却不清楚到哪里找人指导。 14.** 同道中人（KindredSpirits） ** : 你发现自己无人指导，束手无策，而且周围气氛看起来与自己的期望不一致。 15.** 学会失败（Learn How YouFail） ** : 学习能力提高了你的成功几率，但失败和弱点依然存在。 16.** 培养激情（Nurture YourPassion） ** : 你工作在一个不好的环境中，它扼杀你对软件工艺的激情。 17.** 不断实践（Practice,Practice,Practice） ** : 日常编程活动不会给你通过犯错来学习的机会。 18.** 坚持阅读（ReadConstantly） ** : 虽然你快速掌握了许多东西，你尚未搞懂的更深入、更基本的概念却源源不断地出现。 19.** 阅读列表（ReadingList） ** : 需要阅读的书籍数量快速增加，你不可能读完它们。 20.** 记录所学（Record What YouLearn） ** : 你一遍又一遍地学到同样的经验。似乎没有一样能持续下来。 21.** 以退为进 （Retreat into Competence） ** : 当你发现了自己的大片无知领域时，你感觉自己要被淹没了。 22.** 密切交往（RubbingElbows） ** : 你感觉有更高级的技术和方法而自己却抓不住。 23.** 分享所学（Share What YouLearn） ** : 周围的人学习起来没有你快，你感到失望了。 24.** 坚守阵地（Stay in theTrenches） ** : 你获得一次提升的机会，组织想把你提升到一个不再编程的职位上。 25.** 钻研名著（Study theClassics） ** : 你周围更有经验的人们不断地引用一些书中的概念，他们以为你已经读过那些书了。 26.** 持续动力（SustainableMotivations） ** :你发现自己工作在一个令人失望的世界里，做着含糊不清的项目，面对着客户不断摇摆而且相互冲突的需求。 27.** 打扫地面（Sweep theFloor） ** : 你是个缺少经验的开发者，需要赢得团队的信任。 28.** 深水区域（The DeepEnd） ** : 你开始担心自己的职业并没有处在稳定水平，而是陷在了泥沟中。 29.** 漫漫长路（The LongRoad） ** : 你渴望成为一位软件师傅，而你的抱负同人们的期待不一致。 30.** 白色腰带（The WhiteBelt） ** : 你正在奋力学习，因为已有的经验似乎使新技能的学习更加困难了。 31.** 释放激情（Unleash YourEnthusiasm） ** : 你发现自己为了适应团队而压抑自己对软件开发的兴奋和好奇。 32.** 使用源码（Use theSource） ** : 如果你周围的人没有能力区分好代码和坏代码，你如何能认识到自己工作中哪些地方做得好呢？ 33.** 使用头衔（Use YourTitle） ** :当你在职业场合介绍自己的时候，你都会觉得自己必须道歉或者专门解释一下自己技能水平和职位描述之间的差异。 34.** 入门语言（Your FirstLanguage） ** : 你已熟悉了几门语言，但任何一门用得都不流畅。 ","date":"2017-11-03","objectID":"/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%BA%BF%E5%9B%BE%E4%BB%8E%E5%AD%A6%E5%BE%92%E5%88%B0%E9%AB%98%E6%89%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:1","tags":["职业生涯"],"title":"《软件开发者路线图—从学徒到高手》读书笔记","uri":"/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%BA%BF%E5%9B%BE%E4%BB%8E%E5%AD%A6%E5%BE%92%E5%88%B0%E9%AB%98%E6%89%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础"],"content":"基本概念 switch语句和if else类似是一种选择语句。根据整数表达式的值，switch语句从一系列代码中选出一段执行。 switch (key) { case 1: //do something... break; case 2: //do something... break; default: //do something... break; } 注意： switch 语句可以处理 int，short，byte，char 类型的值，但是不能处理 long。因为 short，byte，char都会转换成 int 进行处理，这一点也可以从生成的字节码看出。 在 JDK 5 中加入枚举 Enum 类型也可以作为 case 值的。 ** JDK 7 中加入字符串 String 类型作为 case 值的，** 这是Java提供的语法糖，本质上switch语句处理还是整型。 ","date":"2017-09-15","objectID":"/java%E5%85%B3%E9%94%AE%E5%AD%97switch/:1:0","tags":["java"],"title":"Java关键字switch","uri":"/java%E5%85%B3%E9%94%AE%E5%AD%97switch/"},{"categories":["Java基础"],"content":"原理分析 switch对字符串支持的实现 先上段demo /** * Java Program to demonstrate how string in switch functionality is implemented in * Java SE 7 release. */ public class StringInSwitchCase { public static void main(String[] args) { String mode = \"ACTIVE\"; switch (mode) { case \"ACTIVE\": System.out.println(\"Application is running on Active mode\"); break; case \"PASSIVE\": System.out.println(\"Application is running on Passive mode\"); break; case \"SAFE\": System.out.println(\"Application is running on Safe mode\"); default: System.out.println(\"Application unknow\"); break; } } } 利用IDEA打开StringInSwitchCase.class文件，反编译后，结果如下： // // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // public class StringInSwitchCase { public StringInSwitchCase() { } public static void main(String[] args) { String mode = \"ACTIVE\"; byte var3 = -1; switch(mode.hashCode()) { case -74056953: if (mode.equals(\"PASSIVE\")) { var3 = 1; } break; case 2537357: if (mode.equals(\"SAFE\")) { var3 = 2; } break; case 1925346054: if (mode.equals(\"ACTIVE\")) { var3 = 0; } } switch(var3) { case 0: System.out.println(\"Application is running on Active mode\"); break; case 1: System.out.println(\"Application is running on Passive mode\"); break; case 2: System.out.println(\"Application is running on Safe mode\"); default: System.out.println(\"Application unknow\"); } } } 看到反编译后的代码，可知原来字符串的switch是通过equals()和hashCode()方法来实现的。 记住，本质上switch中只能使用整型，比如byte、short、char(ackii码是整型)以及int。hashCode()方法返回的是int，而不是long。通过这个很容易记住hashCode返回的是int这个事实。 仔细看下可以发现，进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。因为Java编译器只增加了一个equals方法，如果你比较的是字符串字面量的话会非常快，比如”abc” ==”abc”。如果你把hashCode()方法的调用也考虑进来了，那么还会再多一次的调用开销，因为字符串一旦创建了，它就会把哈希值缓存起来。因此如果这个siwtch语句是用在一个循环里的，比如逐项处理某个值，或者游戏引擎循环地渲染屏幕，这里hashCode()方法的调用开销其实不会很大。 ","date":"2017-09-15","objectID":"/java%E5%85%B3%E9%94%AE%E5%AD%97switch/:2:0","tags":["java"],"title":"Java关键字switch","uri":"/java%E5%85%B3%E9%94%AE%E5%AD%97switch/"},{"categories":["Java基础"],"content":"参考文章： http://www.importnew.com/14597.html https://blog.csdn.net/u012420654/article/details/59707677 https://www.jianshu.com/p/9103ab536bbe ","date":"2017-09-15","objectID":"/java%E5%85%B3%E9%94%AE%E5%AD%97switch/:2:1","tags":["java"],"title":"Java关键字switch","uri":"/java%E5%85%B3%E9%94%AE%E5%AD%97switch/"},{"categories":null,"content":"如果想了解IT、互联网，那么这本《浪潮之巅》应该算是必读的书。 下面引用亚马逊的推荐语 《浪潮之巅》不只是一本历史书，除了讲述科技顶尖企业的发展规律，对于华尔街如何左右科技公司，以及金融风暴对科技产业的冲击，也多有着墨。此外，《浪潮之巅(第2版)(套装上下册)》也着力讲述很多尚在普及或将要发生的，比如微博和云计算，以及对下一代互联网科技产业浪潮的判断和预测。因为在极度商业化的今天，科技的进步和商机是分不开的。 诚如作者所言：“人的商业知识和眼光不是天生的，需要不断地、有心地学习。经过多年的学习、思考和实践，我认定这样一个规律，就是：科技的发展不是均匀的，而是以浪潮的形式出现。每一个人都应该看清楚浪潮，赶上浪潮，如此，便不枉此生。” 购买链接 下面是自己写的关于《浪潮之巅》的思维导图 作者简介： 吴军，毕业于清华大学和美国约翰•霍普金斯大学（博士），是著名自然语言处理和搜索专家，硅谷风险投资人。吴军博士于2002年加入谷歌公司。在谷歌，他和Amit Singhal（谷歌院士，世界著名搜索专家）、Matt Cutts（谷歌反作弊官方发言人）等三位同事一起开创了网络搜索反作弊的研究领域，并因此获得谷歌工程奖。 2003年，他和谷歌全球架构的总工程师朱会灿博士等共同成立了中日韩文搜索部门。吴军博士是当前谷歌中日韩文搜索算法的主要设计者。在谷歌期间，他还领导了许多研发项目，包括许多与中文相关的产品和自然语言处理的项目，并得到了当时公司首席执行官埃里克•施密特和创始人谢尔盖•布林的高度评价。 2010年加盟腾讯公司，出任负责搜索和搜索广告的副总裁。2012年回到谷歌，领导创新项目。目前任谷歌公司的Principal Engineer。 ","date":"2017-09-11","objectID":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:0:0","tags":["IT"],"title":"《浪潮之巅》读书笔记","uri":"/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["经验总结"],"content":" 今天打开kindle准备看《浪潮之巅》，发现没有自动同步我在手机上看的页数，一看是kindle没连上Wi-Fi，然后就主动去连接Wi-Fi。 但连接Wi-Fi后显示** Kindle已连接WiFi网络，但无法连接互联网的解决办法 ** kindle前几天都还可以连网，现在突然突然不行了。不能联网的kindle就没法同步用手机kindle软件看书的进度、并且不能推送电子书了。 看到这报错第一反应是，手机连上Wi-Fi了看能不能联网，后发现手机连上同样的Wi-Fi是可以上网的。感觉不像是家里网络的问题。 想到第一种解决办法是重启kindle（据说重启能解决80%的计算机问题），然后并没什么卵用。 后来上网搜了一下该问题，寻找解决办法。找到了一种可行的解决办法，特此记录一下。 ","date":"2017-09-02","objectID":"/kindle%E5%B7%B2%E8%BF%9E%E6%8E%A5wifi%E7%BD%91%E7%BB%9C%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:0:0","tags":["kindle"],"title":"Kindle已连接WiFi网络，但无法连接互联网的解决办法","uri":"/kindle%E5%B7%B2%E8%BF%9E%E6%8E%A5wifi%E7%BD%91%E7%BB%9C%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["经验总结"],"content":"解决办法 1、在Kindle U盘根目录建立一个txt文件，名为“WIFI_NO_NET_PROBE” 2、去掉txt后缀名 3、然后重启，如此就能避开Kindle连网时的网络验证，可以很顺利地连上WiFi了 ","date":"2017-09-02","objectID":"/kindle%E5%B7%B2%E8%BF%9E%E6%8E%A5wifi%E7%BD%91%E7%BB%9C%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:0:1","tags":["kindle"],"title":"Kindle已连接WiFi网络，但无法连接互联网的解决办法","uri":"/kindle%E5%B7%B2%E8%BF%9E%E6%8E%A5wifi%E7%BD%91%E7%BB%9C%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":null,"content":"java是一门强类型语言，每个变量都必须声明类型。第一次变量赋值称为变量的初始化。 ","date":"2017-08-24","objectID":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["java"],"title":"java基本数据类型","uri":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"一、java基本数据类型及其包装类 java共有八种基本类型：四种是整型，两种是浮点数字型，一种是字符型char（用于Unicode编码中的字符），以及表示真假的布尔类型boolean。 类型 位数 最大存储量 范围 byte 8位 255 -128~127之间 short 16位 65536 -32768~32767之间 int 32位 2的32次方减1 负的2的31次方到正的2的31次方减1 long 64位 2的64次方减1 负的2的63次方到正的2的63次方减1 float 32位 3.4e-45~1.4e38 直接赋值时必须在数字后加上f或F double 64位 4.9e-324~1.8e308 赋值时可以加d或D也可以不加 boolean 只有true和false两个取值 char 16位 存储Unicode码 用单引号赋值 Java决定了每种简单类型的大小。这些大小并不随着机器结构的变化而变化。 这种大小的不可更改正是Java程序具有很强移植能力的原因之一。 下表列出了Java中定义的简单类型、占用二进制位数及对应的封装器类。 简单类型 boolean byte char short Int long float double void 二进制位数 1 8 16 16 32 64 32 64 – 封装器类 Boolean Byte Character Short Integer Long Float Double Void 浮点类型的数据是用二进制表示的，分数1/10在二进制时无法精确表示的。 System.out.println(2.0-1.1); 将会打印0.899999999而不是0.9 char常量用单引号表示，常用于表示Unicode编码表的字符 布尔类型和整数不能相互转换。 Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。 从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。 另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。 ** 基本类型的优势 ** ：数据存储相对简单，运算效率比较高 ** 包装类的优势 ** ：集合的元素必须是对象类型，满足了java一切皆是对象的思想 ","date":"2017-08-24","objectID":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:1","tags":["java"],"title":"java基本数据类型","uri":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"二、java变量、常量 java中使用 ** final ** 来表示常量。习惯上常量名大写。 在java中，希望一个变量在某个类的多个方法可用，通常称为类常量（class constants），使用static final 即可设定类常量。 static final double pi = 3.15 永远不要使用一个未初始化的变量的值。声明变量后，记得通过赋值语句对他明确初始化。 ","date":"2017-08-24","objectID":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:2","tags":["java"],"title":"java基本数据类型","uri":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"三、操作符 1、算术操作符： + — * ／和取余% 2、关系操作符： \u003c 、 \u003c=、 \u003e、 \u003e=、 3、逻辑操作符：\u0026\u0026、|| 、！=、！、== （\u0026\u0026和 || 是短路方式求值，即a \u0026\u0026 b 求值时，一旦a为false，b的值将不会计算） 4、三元操作符： ?: 条件表达式 condition ？e1 : e2 如果condition为true值为e1，否则值为e2 5、位操作符： \u0026（与）、|（或）、^（异或） 、～（非）、\u003c\u003c、\u003e\u003e（此\u0026和| 不会按短路方式计算） ","date":"2017-08-24","objectID":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:3","tags":["java"],"title":"java基本数据类型","uri":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"四、数据类型之间的转换 1).简单类型数据间的转换,有两种方式:自动转换和强制转换,通常发生在表达式中或方法的参数传递时。 自动转换 具体地讲,当一个较”小”数据与一个较”大”的数据一起运算时,系统将自动将”小”数据转换成”大”数据,再进行运算。而在方法调用时,实际参数较”小”,而被调用的方法的形式参数数据又较”大”时(若有匹配的,当然会直接调用匹配的方法),系统也将自动将”小”数据转换成”大”数据,再进行方法的调用,自然,对于多个同名的重载方法,会转换成最”接近”的”大”数据并进行调用。这些类型由”小”到”大”分别为 (byte，short，char)–int–long–float—double。这里我们所说的”大”与”小”,并不是指占用字节的多少,而是指表示值的范围的大小。 ①下面的语句可以在Java中直接通过： byte b;int i=b; long l=b; float f=b; double d=b; ②如果低级类型为char型，向高级类型（整型）转换时，会转换为对应ASCII码值，例如 char c='c'; int i=c; System.out.println(\"output:\"+i);输出：output:99; ③对于byte,short,char三种类型而言，他们是平级的，因此不能相互自动转换，可以使用下述的强制类型转换。 short i=99 ; char c=(char)i; System.out.println(\"output:\"+c);输出：output:c; 强制转换 将”大”数据转换为”小”数据时，你可以使用强制类型转换。即你必须采用下面这种语句格式： int n=(int)3.14159/2;可以想象，这种转换肯定可能会导致溢出或精度的下降。 2)表达式的数据类型自动提升, 关于类型的自动提升，注意下面的规则。 ①所有的byte,short,char型的值将被提升为int型； ②如果有一个操作数是long型，计算结果是long型； ③如果有一个操作数是float型，计算结果是float型； ④如果有一个操作数是double型，计算结果是double型； 例， byte b; b=3; b=(byte)(b*3);//必须声明byte。 3)包装类过渡类型转换 一般情况下，我们首先声明一个变量，然后生成一个对应的包装类，就可以利用包装类的各种方法进行类型转换了。例如： ①当希望把float型转换为double型时： float f1=100.00f; Float F1=new Float(f1); double d1=F1.doubleValue();//F1.doubleValue()为Float类的返回double值型的方法 ②当希望把double型转换为int型时： double d1=100.00; Double D1=new Double(d1); int i1=D1.intValue(); 简单类型的变量转换为相应的包装类，可以利用包装类的构造函数。即：Boolean(boolean value)、Character(char value)、Integer(int value)、Long(long value)、Float(float value)、Double(double value) 而在各个包装类中，总有形为××Value()的方法，来得到其对应的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换，例如，对于一个双精度实型类，intValue()可以得到其对应的整型变量，而doubleValue()可以得到其对应的双精度实型变量。 4)字符串与其它类型间的转换 其它类型向字符串的转换 ①调用类的串转换方法:X.toString(); ②自动转换:X+”“; ③使用String的方法:String.volueOf(X); 字符串作为值,向其它类型的转换 ①先转换成相应的封装器实例,再调用对应的方法转换成其它类型 例如，字符中”32.1”转换double型的值的格式为:new Float(“32.1”).doubleValue()。也可以用:Double.valueOf(“32.1”).doubleValue() ②静态parseXXX方法 String s = “1”; byte b = Byte.parseByte( s ); short t = Short.parseShort( s ); int i = Integer.parseInt( s ); long l = Long.parseLong( s ); Float f = Float.parseFloat( s ); Double d = Double.parseDouble( s ); ③Character的getNumericValue(char ch)方法 5）Date类与其它数据类型的相互转换 整型和Date类之间并不存在直接的对应关系，只是你可以使用int型为分别表示年、月、日、时、分、秒，这样就在两者之间建立了一个对应关系，在作这种转换时，你可以使用Date类构造函数的三种形式： ①Date(int year, int month, int date)：以int型表示年、月、日 ②Date(int year, int month, int date, int hrs, int min)：以int型表示年、月、日、时、分 ③Date(int year, int month, int date, int hrs, int min, int sec)：以int型表示年、月、日、时、分、秒 在长整型和Date类之间有一个很有趣的对应关系，就是将一个时间表示为距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数。对于这种对应关系，Date类也有其相应的构造函数：Date(long date)。 获取Date类中的年、月、日、时、分、秒以及星期你可以使用Date类的getYear()、getMonth()、getDate()、getHours()、getMinutes()、getSeconds()、getDay()方法，你也可以将其理解为将Date类转换成int。 而Date类的getTime()方法可以得到我们前面所说的一个时间对应的长整型数，与包装类一样，Date类也有一个toString()方法可以将其转换为String类。 有时我们希望得到Date的特定格式，例如20020324，我们可以使用以下方法，首先在文件开始引入， import java.text.SimpleDateFormat; import java.util.*; java.util.Date date = new java.util.Date(); //如果希望得到YYYYMMDD的格式 SimpleDateFormat sy1=new SimpleDateFormat(\"yyyyMMDD\"); String dateFormat=sy1.format(date); //如果希望分开得到年，月，日 SimpleDateFormat sy=new SimpleDateFormat(\"yyyy\"); SimpleDateFormat sm=new SimpleDateFormat(\"MM\"); SimpleDateFormat sd=new SimpleDateFormat(\"dd\"); String syear=sy.format(date); String smon=sm.format(date); String sday=sd.format(date); ** 总结 ** ：只有boolean不参与数据类型的转换 ** （1）.自动类型的转换 ** ： a.常数在表数范围内是能够自动类型转换的. b.数据范围小的能够自动数据类型大的转换（注意特例） int到float，long到float，long到double 是不会自动转换的，不然将会丢失精度 c.引用类型能够自动转换为父类的 d.基本类型和它们包装类型是能够互相转换的 ** （2）.强制类型转换 ** ：用圆括号括起来目标类型，置于变量前 int n=(int)3.1415 . ","date":"2017-08-24","objectID":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:4","tags":["java"],"title":"java基本数据类型","uri":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"五、Java引用类型 Java有 5种引用类型（对象类型）：类 接口 数组 枚举 标注 引用类型：底层结构和基本类型差别较大 JVM的内存空间： （1）. Heap 堆空间：分配对象 new Student（） （2）. Stack 栈空间：临时变量 Student stu （3）.Code 代码区 ：类的定义，静态资源 Student.class eg：Student stu = new Student（）； //new 在内存的堆空间创建对象 stu.study(); //把对象的地址赋给stu引用变量 上例实现步骤： a. JVM加载Student.class 到Code区 b. new Student()在堆空间分配空间并创建一个Student实例 c. 将此实例的地址赋值给引用stu， 栈空间. ","date":"2017-08-24","objectID":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:5","tags":["java"],"title":"java基本数据类型","uri":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"俗话说得好：工欲善其事必先利其器。有几款我自己在使用，觉得不错的chome插件，记录并分享给大家。 ","date":"2016-12-15","objectID":"/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:0:0","tags":["chrome插件"],"title":"推荐几款好用的chrome插件（持续更新）","uri":"/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":null,"content":"一、AdBlock AdBlock是一款chrome中非常著名的广告屏蔽插件，其在chrome浏览器中的安装量已经高达4000万，如此多的安装用户已经足以证明其的强大之处，对于AdBlock本身来说，其号称能够屏蔽整个互联网上的广告。 对于普通网站上的广告单元、漂浮广告、视频播放广告、图片广告等，AdBlock都能很好地进行处理，使得用户的Chrome浏览环境瞬间变成小清新。 AdBlock官网下载 ","date":"2016-12-15","objectID":"/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:1:0","tags":["chrome插件"],"title":"推荐几款好用的chrome插件（持续更新）","uri":"/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":null,"content":"二、有道词典chrome划词插件 作为程序员，时常要阅读英文材料，但英文词汇量的欠缺，读起英文不能一气呵成。此时，在有道词典划词插件的帮助下，哪里不懂划哪里：） 有道词典官网下载 ","date":"2016-12-15","objectID":"/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:2:0","tags":["chrome插件"],"title":"推荐几款好用的chrome插件（持续更新）","uri":"/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":null,"content":"三、一览阅读RSS阅读器 一览作为国内较好用的RSS阅读器 支持全平台（ IOS + Android + Web + Chrome 插件） 支持订阅绝大多数“墙外”的 RSS、订阅知乎用户 支持全站搜索（免费用户有限制） 目前有 100 个订阅数的限制（邀请好友或者 VIP 可以增加） 一览chrome插件 ","date":"2016-12-15","objectID":"/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/:3:0","tags":["chrome插件"],"title":"推荐几款好用的chrome插件（持续更新）","uri":"/%E6%8E%A8%E8%8D%90%E5%87%A0%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84chrome%E6%8F%92%E4%BB%B6%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"categories":null,"content":"这本书并没有想象中的好，作者达到财富自由的方法并不适合中国国情。不过里面的一些观点倒是值得学习。要学习财务知识，提高自己的财商，这是在学校教育是缺失的。下面摘抄一些书中我认为不错的观点。 1、必须明白资产和负债的区别，并且尽可能地购买资产。资产就是能把钱放进你口袋的东西，负债就是把钱从你口袋取走的东西。 2、财富是支持一个人生存多长时间的能力，或者说如果我今天停止工作，我还能活多久？（类似于睡后收入) 3、真正的资产可以分为下列几类：1）不要我到场就可以正常运作的业务，我拥有它们，担忧别人经营和管理，如果我必须在那儿工作的话，那就不是我的事业而是我的职业；2）股票；3）债券；4）基金；5）产生收入的房地产；6）票据（借款）；7）专利权如音乐、专利、著作 4、只有把你的增加的收入用于购买可产生收入的资产时，你才能获得真正的财产安全。 5、汽车不是真正的资产。 6、财商由四项主要技能组成：1）财务知识，即阅读理解数字的能力；2）投资战略，即钱生钱的科学；3）市场、供给与需求；4）了解法律 7、富人都是用公司和信托来隐藏部分财富。 8、生活就像我去健身房，最痛苦的事情是作出去锻炼的决定，一旦你过了这一关，以后的事情就好办了。只要去了健身房，心里就会感到非常愉快。做完健身练习，我总是非常高兴对自己说：做运动真好！ 9、这世界上的奇迹之一是复利计息。 10、忙碌的人常常是最懒惰的人。 11、听比说更重要，否则，上帝就不会给我们安排两只耳朵，却只安排一张嘴巴。 12、you are what you eat ! you are what you read ! 13、 ** 是否自律 ** 是讲富人和穷人分开来的因素之一。 14、首先支付自己。—《巴比伦最富有的人》乔治.克拉森 ps：投资自己永远是最划算的投资。 ","date":"2016-11-20","objectID":"/%E6%A0%91%E7%AB%8B%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%87%91%E9%92%B1%E8%A7%82---%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8/:0:0","tags":["理财"],"title":"树立正确的金钱观---《富爸爸，穷爸爸》","uri":"/%E6%A0%91%E7%AB%8B%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%87%91%E9%92%B1%E8%A7%82---%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8/"}]